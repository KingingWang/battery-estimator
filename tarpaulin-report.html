<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","kingingwang","workspace","rust","battery-estimator","examples","basic.rs"],"content":"//! Comprehensive Test - Testing all voltage values including two decimal places\n\nuse battery_estimator::{BatteryChemistry, SocEstimator};\n\nfn main() {\n    println!(\"Battery SOC Estimator - Comprehensive Test\");\n    println!(\"==========================================\\n\");\n\n    // Test all battery types\n    test_battery(BatteryChemistry::LiPo, \"LiPo\", 3.2, 4.2);\n    test_battery(BatteryChemistry::LiFePO4, \"LiFePO4\", 2.5, 3.65);\n    test_battery(BatteryChemistry::LiIon, \"Li-Ion\", 2.5, 4.2);\n    test_battery(\n        BatteryChemistry::Lipo410Full340Cutoff,\n        \"LiPo 4.1V/3.4V (Conservative)\",\n        3.4,\n        4.1,\n    );\n\n    // Test boundary cases\n    println!(\"\\n\\nBoundary Case Tests\");\n    println!(\"===================\\n\");\n    test_boundary_cases();\n\n    // Test error cases\n    println!(\"\\n\\nError Case Tests\");\n    println!(\"================\\n\");\n    test_error_cases();\n}\n\n/// Test specific battery type\nfn test_battery(chemistry: BatteryChemistry, name: \u0026str, min_v: f32, max_v: f32) {\n    println!(\"Testing {} Battery ({}V - {}V):\", name, min_v, max_v);\n    println!(\"{}\", \"-\".repeat(50));\n\n    let estimator = SocEstimator::new(chemistry);\n\n    // 1. Test key voltage points\n    println!(\"\\nKey voltage points:\");\n    let key_voltages = generate_key_voltages(min_v, max_v);\n\n    for voltage in key_voltages {\n        match estimator.estimate_soc(voltage) {\n            Ok(soc) =\u003e println!(\"  {:5.2}V -\u003e {:6.2}%\", voltage, soc),\n            Err(e) =\u003e println!(\"  {:5.2}V -\u003e ERROR: {}\", voltage, e),\n        }\n    }\n\n    // 2. Dense testing of entire range (step 0.01V)\n    println!(\"\\nDense testing (every 0.05V):\");\n    let mut voltage = min_v;\n    let step = 0.05;\n\n    while voltage \u003c= max_v + 0.001 {\n        // Add small tolerance\n        match estimator.estimate_soc(voltage) {\n            Ok(soc) =\u003e {\n                // Only print when SOC changes significantly\n                if should_print(voltage, min_v, max_v, step) {\n                    println!(\"  {:5.2}V -\u003e {:6.2}%\", voltage, soc);\n                }\n            }\n            Err(e) =\u003e println!(\"  {:5.2}V -\u003e ERROR: {}\", voltage, e),\n        }\n        voltage += step;\n    }\n\n    // 3. Test curve characteristic points\n    println!(\"\\nCharacteristic points:\");\n    test_characteristic_points(\u0026estimator, name);\n\n    println!();\n}\n\n/// Generate key voltage points\nfn generate_key_voltages(min_v: f32, max_v: f32) -\u003e Vec\u003cf32\u003e {\n    let mut voltages = Vec::new();\n\n    // Boundary points\n    voltages.push(min_v);\n    voltages.push(max_v);\n\n    // Midpoint\n    let mid = (min_v + max_v) / 2.0;\n    voltages.push(mid);\n\n    // Quartile points\n    voltages.push(min_v + (max_v - min_v) * 0.25);\n    voltages.push(min_v + (max_v - min_v) * 0.75);\n\n    // Specific test points\n    let step = 0.1;\n    let mut v = min_v;\n    while v \u003c= max_v + 0.001 {\n        voltages.push(v);\n        v += step;\n    }\n\n    voltages.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    voltages.dedup();\n    voltages\n}\n\n/// Determine whether printing is needed\nfn should_print(voltage: f32, min_v: f32, max_v: f32, step: f32) -\u003e bool {\n    // Always print boundaries and specific points\n    if (voltage - min_v).abs() \u003c step * 0.5 {\n        return true;\n    }\n    if (voltage - max_v).abs() \u003c step * 0.5 {\n        return true;\n    }\n\n    // Print every 0.1V point\n    let tenth = (voltage * 10.0).round() / 10.0;\n    (voltage - tenth).abs() \u003c step * 0.5\n}\n\n/// Test characteristic points\nfn test_characteristic_points(estimator: \u0026SocEstimator, name: \u0026str) {\n    match name {\n        \"LiPo\" =\u003e {\n            // LiPo characteristic voltages\n            let points = [\n                (3.2, \"Discharge cutoff\"),\n                (3.7, \"Nominal voltage\"),\n                (3.8, \"Mid discharge\"),\n                (3.9, \"High discharge\"),\n                (4.0, \"Near full\"),\n                (4.2, \"Full charge\"),\n            ];\n\n            for (voltage, desc) in points.iter() {\n                match estimator.estimate_soc(*voltage) {\n                    Ok(soc) =\u003e println!(\"  {:5.2}V ({:20}) -\u003e {:6.2}%\", voltage, desc, soc),\n                    Err(e) =\u003e println!(\"  {:5.2}V ({:20}) -\u003e ERROR: {}\", voltage, desc, e),\n                }\n            }\n        }\n        \"LiFePO4\" =\u003e {\n            // LiFePO4 characteristic voltages\n            let points = [\n                (2.5, \"Discharge cutoff\"),\n                (3.0, \"Low voltage\"),\n                (3.2, \"Nominal voltage\"),\n                (3.3, \"Flat region\"),\n                (3.4, \"High voltage\"),\n                (3.65, \"Full charge\"),\n            ];\n\n            for (voltage, desc) in points.iter() {\n                match estimator.estimate_soc(*voltage) {\n                    Ok(soc) =\u003e println!(\"  {:5.2}V ({:20}) -\u003e {:6.2}%\", voltage, desc, soc),\n                    Err(e) =\u003e println!(\"  {:5.2}V ({:20}) -\u003e ERROR: {}\", voltage, desc, e),\n                }\n            }\n        }\n        \"Li-Ion\" =\u003e {\n            // Li-Ion characteristic voltages\n            let points = [\n                (2.5, \"Discharge cutoff\"),\n                (3.0, \"Low voltage\"),\n                (3.7, \"Nominal voltage\"),\n                (4.0, \"High voltage\"),\n                (4.2, \"Full charge\"),\n            ];\n\n            for (voltage, desc) in points.iter() {\n                match estimator.estimate_soc(*voltage) {\n                    Ok(soc) =\u003e println!(\"  {:5.2}V ({:20}) -\u003e {:6.2}%\", voltage, desc, soc),\n                    Err(e) =\u003e println!(\"  {:5.2}V ({:20}) -\u003e ERROR: {}\", voltage, desc, e),\n                }\n            }\n        }\n        \"LiPo 4.1V/3.4V (Conservative)\" =\u003e {\n            // LiPo conservative curve characteristic voltages\n            let points = [\n                (3.4, \"Shutdown cutoff (0%)\"),\n                (3.5, \"Very low (10%)\"),\n                (3.7, \"Low voltage (40%)\"),\n                (3.77, \"Mid voltage (50%)\"),\n                (3.9, \"High voltage (80%)\"),\n                (4.03, \"Near full (95%)\"),\n                (4.1, \"Full charge (100%)\"),\n            ];\n\n            for (voltage, desc) in points.iter() {\n                match estimator.estimate_soc(*voltage) {\n                    Ok(soc) =\u003e println!(\"  {:5.2}V ({:20}) -\u003e {:6.2}%\", voltage, desc, soc),\n                    Err(e) =\u003e println!(\"  {:5.2}V ({:20}) -\u003e ERROR: {}\", voltage, desc, e),\n                }\n            }\n        }\n        _ =\u003e {}\n    }\n}\n\n/// Test boundary cases\nfn test_boundary_cases() {\n    let lipo = SocEstimator::new(BatteryChemistry::LiPo);\n\n    println!(\"Exact boundary values:\");\n    println!(\"  3.20V -\u003e {:.2}%\", lipo.estimate_soc(3.20).unwrap());\n    println!(\"  4.20V -\u003e {:.2}%\", lipo.estimate_soc(4.20).unwrap());\n\n    println!(\"\\nJust outside boundaries:\");\n    println!(\"  3.19V -\u003e {:?}\", lipo.estimate_soc(3.19));\n    println!(\"  4.21V -\u003e {:?}\", lipo.estimate_soc(4.21));\n\n    println!(\"\\nVery close to boundaries:\");\n    println!(\"  3.2001V -\u003e {:.2}%\", lipo.estimate_soc(3.2001).unwrap());\n    println!(\"  4.1999V -\u003e {:.2}%\", lipo.estimate_soc(4.1999).unwrap());\n\n    println!(\"\\nMidpoint exactly:\");\n    let midpoint = (3.2 + 4.2) / 2.0;\n    println!(\n        \"  {:.4}V -\u003e {:.2}%\",\n        midpoint,\n        lipo.estimate_soc(midpoint).unwrap()\n    );\n}\n\n/// Test error cases\nfn test_error_cases() {\n    // Test potential error scenarios here\n    println!(\"Testing with extreme values:\");\n\n    let lipo = SocEstimator::new(BatteryChemistry::LiPo);\n\n    let extreme_voltages = [0.0, -1.0, 10.0, f32::NAN, f32::INFINITY];\n\n    for voltage in extreme_voltages.iter() {\n        match lipo.estimate_soc(*voltage) {\n            Ok(soc) =\u003e println!(\"  {:?}V -\u003e {:.2}%\", voltage, soc),\n            Err(e) =\u003e println!(\"  {:?}V -\u003e ERROR: {}\", voltage, e),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kingingwang","workspace","rust","battery-estimator","examples","custom_curve.rs"],"content":"//! Custom Curve Example\n\nuse battery_estimator::{Curve, CurvePoint, SocEstimator};\n\nfn main() {\n    println!(\"Battery SOC Estimator - Custom Curve Example\");\n    println!(\"============================================\\n\");\n\n    // Create custom curve\n    const CUSTOM_CURVE: Curve = Curve::new(\u0026[\n        CurvePoint::new(3.2, 0.0),\n        CurvePoint::new(3.7, 50.0),\n        CurvePoint::new(4.2, 100.0),\n    ]);\n\n    // Create estimator with custom curve\n    let estimator = SocEstimator::with_custom_curve(\u0026CUSTOM_CURVE);\n\n    // Test\n    let voltages = [4.2, 4.0, 3.8, 3.7, 3.6, 3.5, 3.4, 3.2];\n\n    println!(\"Custom curve:\");\n    for voltage in voltages.iter() {\n        match estimator.estimate_soc(*voltage) {\n            Ok(soc) =\u003e println!(\"  {:.1}V -\u003e {:.1}%\", voltage, soc),\n            Err(e) =\u003e println!(\"  {:.1}V -\u003e Error: {}\", voltage, e),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kingingwang","workspace","rust","battery-estimator","examples","precise_test.rs"],"content":"//! Precise Test - Testing at 0.01V Intervals\n\nuse battery_estimator::{BatteryChemistry, SocEstimator};\n\nfn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    println!(\"Battery SOC Estimator - Precise Voltage Test\");\n    println!(\"============================================\\n\");\n\n    // Test all battery types\n    let chemistries = [\n        (BatteryChemistry::LiPo, \"LiPo\", 3.2, 4.2),\n        (BatteryChemistry::LiFePO4, \"LiFePO4\", 2.5, 3.65),\n        (BatteryChemistry::LiIon, \"Li-Ion\", 2.5, 4.2),\n        (\n            BatteryChemistry::Lipo410Full340Cutoff,\n            \"LiPo 4.1V/3.4V (Conservative)\",\n            3.4,\n            4.1,\n        ),\n    ];\n\n    for (chem, name, min_v, max_v) in chemistries.iter() {\n        println!(\"Testing {} Battery:\", name);\n\n        let estimator = SocEstimator::new(*chem);\n        let step = 0.01; // 0.01V precision\n\n        // Generate test voltages\n        let test_count = ((max_v - min_v) / step) as usize + 1;\n        println!(\"  Voltage range: {}V to {}V\", min_v, max_v);\n        println!(\"  Step: {}V\", step);\n        println!(\"  Total test points: {}\", test_count);\n\n        // Execute test\n        let mut voltage = *min_v;\n        let mut last_soc = -1.0;\n        let mut significant_changes = 0;\n\n        while voltage \u003c= *max_v + 0.0005 {\n            // Add small tolerance\n            match estimator.estimate_soc(voltage) {\n                Ok(soc) =\u003e {\n                    // Only print when SOC changes by more than 0.1%\n                    if (soc - last_soc).abs() \u003e 0.1 || voltage == *min_v || voltage == *max_v {\n                        println!(\"    {:5.2}V -\u003e {:6.2}%\", voltage, soc);\n                        last_soc = soc;\n                        significant_changes += 1;\n                    }\n                }\n                Err(e) =\u003e {\n                    println!(\"    {:5.2}V -\u003e ERROR: {}\", voltage, e);\n                }\n            }\n\n            voltage += step;\n            // Handle floating-point precision\n            voltage = (voltage * 100.0).round() / 100.0;\n        }\n\n        println!(\"  Significant SOC changes: {}\", significant_changes);\n        println!();\n    }\n\n    println!(\"\\nGenerating summary...\");\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kingingwang","workspace","rust","battery-estimator","examples","temperature_compensation_test.rs"],"content":"//! Temperature Compensation Test\n//!\n//! Tests SOC changes at different temperatures, demonstrating temperature compensation effects\n\nuse battery_estimator::{default_temperature_compensation, BatteryChemistry, SocEstimator};\n\nfn main() {\n    println!(\"Battery SOC Estimator - Temperature Compensation Test\");\n    println!(\"=====================================================\\n\");\n\n    // Test all battery types at different temperatures\n    test_all_batteries_with_temperature();\n\n    // Detailed temperature compensation demonstration\n    println!(\"\\n\\nDetailed Temperature Compensation Analysis\");\n    println!(\"==========================================\\n\");\n    detailed_temperature_analysis();\n\n    // Test extreme temperature conditions\n    println!(\"\\n\\nExtreme Temperature Tests\");\n    println!(\"========================\\n\");\n    test_extreme_temperatures();\n}\n\n/// Test all battery types at different temperatures\nfn test_all_batteries_with_temperature() {\n    let chemistries = [\n        (BatteryChemistry::LiPo, \"LiPo\", 3.2, 4.2),\n        (BatteryChemistry::LiFePO4, \"LiFePO4\", 2.5, 3.65),\n        (BatteryChemistry::LiIon, \"Li-Ion\", 2.5, 4.2),\n        (\n            BatteryChemistry::Lipo410Full340Cutoff,\n            \"LiPo 4.1V/3.4V (Conservative)\",\n            3.4,\n            4.1,\n        ),\n    ];\n\n    for (chem, name, min_v, max_v) in chemistries.iter() {\n        println!(\"Testing {} Battery Temperature Effects:\", name);\n        println!(\"{}\", \"-\".repeat(60));\n\n        let estimator = SocEstimator::new(*chem);\n\n        // Test key voltage points at different temperatures\n        let test_temperatures = [-10.0, 0.0, 25.0, 40.0, 60.0];\n        let test_voltages = generate_test_voltages(*min_v, *max_v);\n\n        println!(\"\\nVoltage | {:^48}\", \"SOC at Different Temperatures (°C)\");\n        println!(\"--------|{}\", \"-\".repeat(50));\n        print!(\"        |\");\n        for temp in test_temperatures.iter() {\n            print!(\" {:\u003e7.0}°C |\", temp);\n        }\n        println!();\n        println!(\"--------|{}\", \"-\".repeat(50));\n\n        for voltage in test_voltages.iter() {\n            match estimator.estimate_soc(*voltage) {\n                Ok(base_soc) =\u003e {\n                    print!(\" {:6.2}V |\", voltage);\n\n                    for temp in test_temperatures.iter() {\n                        let compensated = default_temperature_compensation(base_soc, *temp);\n                        print!(\" {:8.2}% |\", compensated);\n                    }\n                    println!();\n                }\n                Err(e) =\u003e println!(\" {:6.2}V | ERROR: {}\", voltage, e),\n            }\n        }\n\n        println!();\n\n        // Show temperature impact on SOC percentage\n        show_temperature_impact(*chem, *min_v, *max_v);\n        println!();\n    }\n}\n\n/// Generate test voltage points\nfn generate_test_voltages(min_v: f32, max_v: f32) -\u003e Vec\u003cf32\u003e {\n    let mut voltages = Vec::new();\n\n    // Boundary points\n    voltages.push(min_v);\n    voltages.push(max_v);\n\n    // Midpoints (25%, 50%, 75%)\n    let range = max_v - min_v;\n    voltages.push(min_v + range * 0.25);\n    voltages.push(min_v + range * 0.50);\n    voltages.push(min_v + range * 0.75);\n\n    // Specific test points (every 0.1V)\n    let step = 0.1;\n    let mut v = min_v + step;\n    while v \u003c max_v {\n        voltages.push(v);\n        v += step;\n    }\n\n    voltages.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    voltages.dedup();\n    voltages\n}\n\n/// Show temperature impact on SOC percentage\nfn show_temperature_impact(chemistry: BatteryChemistry, min_v: f32, max_v: f32) {\n    let estimator = SocEstimator::new(chemistry);\n    let mid_voltage = (min_v + max_v) / 2.0;\n\n    match estimator.estimate_soc(mid_voltage) {\n        Ok(base_soc) =\u003e {\n            println!(\n                \"Temperature impact at {:.2}V (base SOC: {:.1}%):\",\n                mid_voltage, base_soc\n            );\n\n            let temperatures = [-20.0, -10.0, 0.0, 10.0, 20.0, 25.0, 30.0, 40.0, 50.0, 60.0];\n\n            println!(\"  Temp (°C) | SOC (%) | Change (%) | Effect\");\n            println!(\"  ----------|---------|------------|--------\");\n\n            for temp in temperatures.iter() {\n                let compensated = default_temperature_compensation(base_soc, *temp);\n                let change = compensated - base_soc;\n                let change_percent = (change / base_soc) * 100.0;\n\n                let effect = if change.abs() \u003c 0.1 {\n                    \"Negligible\"\n                } else if change \u003e 0.0 {\n                    \"Increased\"\n                } else {\n                    \"Decreased\"\n                };\n\n                println!(\n                    \"  {:\u003e9.0} | {:7.1} | {:\u003e+10.2} | {}\",\n                    temp, compensated, change_percent, effect\n                );\n            }\n        }\n        Err(e) =\u003e println!(\"Error calculating temperature impact: {}\", e),\n    }\n}\n\n/// Detailed temperature compensation analysis\nfn detailed_temperature_analysis() {\n    let estimator = SocEstimator::new(BatteryChemistry::LiPo);\n\n    // Test voltage changes at different temperatures\n    let test_voltages = [3.2, 3.5, 3.7, 3.9, 4.2];\n    let test_temperatures = [-20.0, 0.0, 25.0, 50.0];\n\n    println!(\"Detailed analysis of temperature compensation:\");\n    println!(\"(Showing base SOC and compensated SOC at different temperatures)\");\n    println!();\n\n    for voltage in test_voltages.iter() {\n        match estimator.estimate_soc(*voltage) {\n            Ok(base_soc) =\u003e {\n                println!(\"At {:.1}V (base SOC: {:.1}%):\", voltage, base_soc);\n\n                for temp in test_temperatures.iter() {\n                    let compensated = default_temperature_compensation(base_soc, *temp);\n                    let diff = compensated - base_soc;\n\n                    println!(\n                        \"  {:4.0}°C: {:.1}% ({:+.1}%, {:.1}% relative change)\",\n                        temp,\n                        compensated,\n                        diff,\n                        (diff / base_soc) * 100.0\n                    );\n                }\n                println!();\n            }\n            Err(e) =\u003e println!(\"Error at {:.1}V: {}\", voltage, e),\n        }\n    }\n\n    // Show temperature coefficient effects\n    println!(\"Temperature coefficient explanation:\");\n    println!(\"  Default coefficient: 0.0005 (0.05% per °C)\");\n    println!(\"  This means for every °C away from 25°C:\");\n    println!(\"    SOC changes by 0.05% of its current value\");\n    println!();\n\n    let example_soc = 50.0;\n    let example_temps = [0.0, 50.0];\n\n    for temp in example_temps.iter() {\n        let delta_temp = temp - 25.0;\n        let compensation: f32 = delta_temp * 0.0005 * 100.0; // Convert to percentage\n        let bounded_compensation = compensation.clamp(-5.0, 5.0);\n        let final_soc = example_soc * (1.0 - bounded_compensation / 100.0);\n\n        println!(\"  Example at {}°C (Δ={}°C from 25°C):\", temp, delta_temp);\n        println!(\"    Theoretical compensation: {:.2}%\", compensation);\n        println!(\n            \"    Bounded compensation: {:.2}% (max ±5%)\",\n            bounded_compensation\n        );\n        println!(\"    Final SOC: {:.1}% (from 50.0%)\", final_soc);\n        println!();\n    }\n}\n\n/// Test extreme temperature conditions\nfn test_extreme_temperatures() {\n    let estimator = SocEstimator::new(BatteryChemistry::LiPo);\n    let voltage = 3.7;\n\n    match estimator.estimate_soc(voltage) {\n        Ok(base_soc) =\u003e {\n            println!(\n                \"Testing extreme temperatures at {:.1}V (base SOC: {:.1}%):\",\n                voltage, base_soc\n            );\n\n            let extreme_temps = [\n                (-40.0, \"Extreme cold (arctic winter)\"),\n                (-20.0, \"Very cold (winter)\"),\n                (0.0, \"Freezing\"),\n                (25.0, \"Room temperature\"),\n                (40.0, \"Hot day\"),\n                (60.0, \"Very hot\"),\n                (85.0, \"Maximum operating temp\"),\n            ];\n\n            println!(\"  Temperature        | Description              | SOC (%) | Change (%)\");\n            println!(\"  -------------------|--------------------------|---------|-----------\");\n\n            for (temp, desc) in extreme_temps.iter() {\n                let compensated = default_temperature_compensation(base_soc, *temp);\n                let change = compensated - base_soc;\n\n                println!(\n                    \"  {:\u003e7.0}°C         | {:24} | {:7.1} | {:\u003e+9.1}\",\n                    temp, desc, compensated, change\n                );\n            }\n\n            println!();\n            println!(\"Key observations:\");\n            println!(\"  1. Temperature compensation is bounded to ±5% maximum\");\n            println!(\"  2. At extreme cold (-40°C): SOC appears higher (battery less efficient)\");\n            println!(\"  3. At extreme heat (85°C): SOC appears lower (battery ages faster)\");\n            println!(\"  4. This is a simplified model - real batteries have more complex behavior\");\n        }\n        Err(e) =\u003e println!(\"Error: {}\", e),\n    }\n\n    // Test compensation boundaries\n    println!(\"\\nTesting compensation bounds:\");\n    test_compensation_bounds();\n}\n\n/// Test compensation boundaries\nfn test_compensation_bounds() {\n    let estimator = SocEstimator::new(BatteryChemistry::LiPo);\n    let voltage = 3.7;\n\n    match estimator.estimate_soc(voltage) {\n        Ok(base_soc) =\u003e {\n            // Test cases exceeding ±5% compensation limit\n            let test_cases = [\n                (-100.0, \"Should be limited to +5%\"),\n                (-50.0, \"Should be limited to +5%\"),\n                (100.0, \"Should be limited to -5%\"),\n                (150.0, \"Should be limited to -5%\"),\n            ];\n\n            for (temp, desc) in test_cases.iter() {\n                let compensated = default_temperature_compensation(base_soc, *temp);\n                let change = compensated - base_soc;\n                let change_percent = (change / base_soc) * 100.0;\n\n                println!(\n                    \"  {:\u003e6.0}°C: {} -\u003e Change: {:.1}% ({:.1}%)\",\n                    temp, desc, change, change_percent\n                );\n            }\n\n            println!();\n            println!(\n                \"Note: Temperature compensation is clamped to ±5% to prevent unrealistic values.\"\n            );\n        }\n        Err(e) =\u003e println!(\"Error: {}\", e),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kingingwang","workspace","rust","battery-estimator","src","compensation.rs"],"content":"//! Temperature and aging compensation for battery SOC estimation\n//!\n//! This module provides functions to adjust SOC estimates based on\n//! environmental conditions and battery age.\n\n/// Applies temperature compensation to SOC value\n///\n/// Battery performance varies with temperature. This function adjusts\n/// the estimated SOC to account for temperature effects on battery capacity.\n///\n/// # Physics Model\n///\n/// At low temperatures, battery internal resistance increases, reducing\n/// the effective available capacity. At high temperatures, the battery\n/// operates more efficiently but may degrade faster over time.\n///\n/// This function adjusts the **reported SOC** to reflect the actual\n/// usable capacity at the current temperature.\n///\n/// # Arguments\n///\n/// * `soc` - Base SOC percentage (0.0 to 100.0)\n/// * `temperature` - Current battery temperature in Celsius\n/// * `nominal_temp` - Nominal/reference temperature in Celsius (typically 25°C)\n/// * `coefficient` - Temperature coefficient (capacity loss per °C below nominal, e.g., 0.005 = 0.5%/°C)\n///\n/// # Returns\n///\n/// Temperature-compensated SOC percentage, or the original SOC if inputs are invalid (NaN/Infinity)\n///\n/// # Behavior\n///\n/// - At nominal temperature: No adjustment\n/// - Below nominal: SOC decreases (less usable capacity due to higher internal resistance)\n/// - Above nominal: SOC increases slightly (better efficiency, capped for safety)\n/// - Compensation is bounded to prevent unrealistic values\n///\n/// # Examples\n///\n/// ```\n/// use battery_estimator::compensate_temperature;\n///\n/// // At nominal temperature (25°C)\n/// let soc = compensate_temperature(50.0, 25.0, 25.0, 0.005);\n/// assert_eq!(soc, 50.0);\n///\n/// // At cold temperature (0°C) - 25°C below nominal\n/// // Capacity reduced by 25 * 0.005 = 12.5%\n/// let cold_soc = compensate_temperature(50.0, 0.0, 25.0, 0.005);\n/// assert!(cold_soc \u003c 50.0); // SOC decreases in cold\n///\n/// // At warm temperature (35°C) - 10°C above nominal\n/// let warm_soc = compensate_temperature(50.0, 35.0, 25.0, 0.005);\n/// assert!(warm_soc \u003e= 50.0); // SOC may increase slightly in warmth\n/// ```\n#[inline]\npub fn compensate_temperature(\n    soc: f32,\n    temperature: f32,\n    nominal_temp: f32,\n    coefficient: f32,\n) -\u003e f32 {\n    // Validate inputs - return original SOC if invalid\n    if !soc.is_finite()\n        || !temperature.is_finite()\n        || !nominal_temp.is_finite()\n        || !coefficient.is_finite()\n    {\n        return soc;\n    }\n\n    let delta_temp = temperature - nominal_temp;\n\n    // Calculate capacity factor based on temperature difference\n    // Below nominal: capacity decreases (factor \u003c 1.0)\n    // Above nominal: capacity increases slightly (factor \u003e 1.0, but capped)\n    let capacity_change = if delta_temp \u003c 0.0 {\n        // Cold: reduce capacity (more aggressive effect)\n        delta_temp * coefficient\n    } else {\n        // Warm: slight capacity increase (less aggressive, capped at 5%)\n        (delta_temp * coefficient * 0.5).min(0.05)\n    };\n\n    // Apply compensation: cold reduces SOC, warm increases SOC slightly\n    // Bound the total compensation to reasonable limits (-30% to +5%)\n    let bounded_change = clamp(capacity_change, -0.30, 0.05);\n\n    soc * (1.0 + bounded_change)\n}\n\n/// Applies aging compensation to SOC value\n///\n/// Battery capacity degrades over time due to chemical aging.\n/// This function adjusts the estimated SOC to account for capacity loss.\n///\n/// # Arguments\n///\n/// * `soc` - Base SOC percentage (0.0 to 100.0)\n/// * `age_years` - Battery age in years (must be non-negative)\n/// * `aging_factor` - Aging factor (capacity loss per year, e.g., 0.02 = 2%/year)\n///\n/// # Returns\n///\n/// Age-compensated SOC percentage, or the original SOC if inputs are invalid\n///\n/// # Behavior\n///\n/// - New battery (0 years): No adjustment\n/// - Aged battery: SOC appears lower due to reduced capacity\n/// - Maximum compensation is 50% (to prevent unrealistic values)\n/// - Invalid inputs (NaN, Infinity, negative age) return original SOC\n///\n/// # Examples\n///\n/// ```\n/// use battery_estimator::compensate_aging;\n///\n/// // New battery\n/// let soc = compensate_aging(50.0, 0.0, 0.02);\n/// assert_eq!(soc, 50.0);\n///\n/// // 2-year-old battery\n/// let aged_soc = compensate_aging(50.0, 2.0, 0.02);\n/// assert!(aged_soc \u003c 50.0); // Reduced by ~4%\n/// ```\n#[inline]\npub fn compensate_aging(soc: f32, age_years: f32, aging_factor: f32) -\u003e f32 {\n    // Validate inputs - return original SOC if invalid\n    if !soc.is_finite() || !age_years.is_finite() || !aging_factor.is_finite() {\n        return soc;\n    }\n\n    // Negative age doesn't make sense, treat as no aging\n    if age_years \u003c 0.0 {\n        return soc;\n    }\n\n    // Negative aging factor doesn't make sense, treat as no aging\n    if aging_factor \u003c 0.0 {\n        return soc;\n    }\n\n    let age_compensation = age_years * aging_factor;\n    soc * (1.0 - clamp(age_compensation, 0.0, 0.5)) // Max 50% compensation\n}\n\n/// Applies default temperature compensation\n///\n/// This is a convenience function that uses standard default values:\n/// - Nominal temperature: 25°C\n/// - Temperature coefficient: 0.005 (0.5% capacity loss per °C below nominal)\n///\n/// # Arguments\n///\n/// * `soc` - Base SOC percentage (0.0 to 100.0)\n/// * `temperature` - Current battery temperature in Celsius\n///\n/// # Returns\n///\n/// Temperature-compensated SOC percentage using default parameters\n///\n/// # Examples\n///\n/// ```\n/// use battery_estimator::default_temperature_compensation;\n///\n/// // At room temperature (25°C) - no change\n/// let soc = default_temperature_compensation(50.0, 25.0);\n/// assert_eq!(soc, 50.0);\n///\n/// // At cold temperature (0°C) - capacity reduced\n/// let cold_soc = default_temperature_compensation(50.0, 0.0);\n/// assert!(cold_soc \u003c 50.0); // SOC decreases in cold\n/// ```\n#[inline]\npub fn default_temperature_compensation(soc: f32, temperature: f32) -\u003e f32 {\n    const NOMINAL_TEMP: f32 = 25.0;\n    const COEFFICIENT: f32 = 0.005; // 0.5% capacity loss per °C below nominal\n\n    compensate_temperature(soc, temperature, NOMINAL_TEMP, COEFFICIENT)\n}\n\n/// Clamps a value between minimum and maximum bounds\n///\n/// # Arguments\n///\n/// * `value` - Value to clamp\n/// * `min` - Minimum allowed value\n/// * `max` - Maximum allowed value\n///\n/// # Returns\n///\n/// Clamped value within [min, max] range\nfn clamp(value: f32, min: f32, max: f32) -\u003e f32 {\n    value.clamp(min, max)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_temperature_compensation_at_nominal() {\n        // Room temperature (25°C) should have no change\n        assert_eq!(default_temperature_compensation(50.0, 25.0), 50.0);\n        assert_eq!(compensate_temperature(50.0, 25.0, 25.0, 0.005), 50.0);\n    }\n\n    #[test]\n    fn test_temperature_compensation_cold() {\n        // Cold temperature should DECREASE SOC (less usable capacity)\n        let cold_compensated = default_temperature_compensation(50.0, 0.0);\n        assert!(\n            cold_compensated \u003c 50.0,\n            \"Cold should decrease SOC due to reduced capacity\"\n        );\n\n        // At 0°C (25°C below nominal), with 0.5%/°C coefficient:\n        // Expected: 50.0 * (1.0 - 0.125) = 43.75\n        let expected = 50.0 * (1.0 + (-25.0 * 0.005));\n        assert!(\n            (cold_compensated - expected).abs() \u003c 0.01,\n            \"Cold compensation calculation mismatch\"\n        );\n    }\n\n    #[test]\n    fn test_temperature_compensation_warm() {\n        // Warm temperature should slightly INCREASE SOC (better efficiency)\n        let warm_compensated = default_temperature_compensation(50.0, 35.0);\n        assert!(\n            warm_compensated \u003e= 50.0,\n            \"Warm should increase or maintain SOC\"\n        );\n    }\n\n    #[test]\n    fn test_temperature_compensation_bounds() {\n        // Test boundary limits\n        // Extreme cold: should be limited to -30% max\n        let extreme_cold = default_temperature_compensation(50.0, -100.0);\n        assert!(\n            extreme_cold \u003e= 50.0 * 0.70,\n            \"Extreme cold should be limited to -30%\"\n        );\n\n        // Extreme hot: should be limited to +5% max\n        let extreme_hot = default_temperature_compensation(50.0, 150.0);\n        assert!(\n            extreme_hot \u003c= 50.0 * 1.05,\n            \"Extreme hot should be limited to +5%\"\n        );\n    }\n\n    #[test]\n    fn test_aging_compensation_invalid_inputs() {\n        // Test NaN input for soc\n        let nan_soc = compensate_aging(f32::NAN, 1.0, 0.02);\n        assert!(nan_soc.is_nan(), \"NaN SOC should return NaN\");\n\n        // Test Infinity input for age_years\n        let inf_age = compensate_aging(50.0, f32::INFINITY, 0.02);\n        assert_eq!(inf_age, 50.0, \"Infinity age should return original SOC\");\n\n        // Test NaN input for aging_factor\n        let nan_factor = compensate_aging(50.0, 1.0, f32::NAN);\n        assert_eq!(\n            nan_factor, 50.0,\n            \"NaN aging_factor should return original SOC\"\n        );\n    }\n\n    #[test]\n    fn test_aging_compensation_negative_age() {\n        // Negative age should be treated as no aging\n        let negative_age = compensate_aging(50.0, -1.0, 0.02);\n        assert_eq!(\n            negative_age, 50.0,\n            \"Negative age should return original SOC\"\n        );\n    }\n\n    #[test]\n    fn test_aging_compensation_negative_factor() {\n        // Negative aging factor should be treated as no aging\n        let negative_factor = compensate_aging(50.0, 1.0, -0.02);\n        assert_eq!(\n            negative_factor, 50.0,\n            \"Negative aging_factor should return original SOC\"\n        );\n    }\n\n    #[test]\n    fn test_temperature_compensation_invalid_inputs() {\n        // Test NaN inputs\n        let nan_soc = compensate_temperature(f32::NAN, 25.0, 25.0, 0.005);\n        assert!(nan_soc.is_nan(), \"NaN SOC should return NaN\");\n\n        let nan_temp = compensate_temperature(50.0, f32::NAN, 25.0, 0.005);\n        assert_eq!(nan_temp, 50.0, \"NaN temperature should return original SOC\");\n\n        let nan_nominal = compensate_temperature(50.0, 25.0, f32::NAN, 0.005);\n        assert_eq!(\n            nan_nominal, 50.0,\n            \"NaN nominal_temp should return original SOC\"\n        );\n\n        let nan_coeff = compensate_temperature(50.0, 25.0, 25.0, f32::NAN);\n        assert_eq!(\n            nan_coeff, 50.0,\n            \"NaN coefficient should return original SOC\"\n        );\n\n        // Test Infinity inputs\n        let inf_temp = compensate_temperature(50.0, f32::INFINITY, 25.0, 0.005);\n        assert_eq!(\n            inf_temp, 50.0,\n            \"Infinity temperature should return original SOC\"\n        );\n    }\n\n    #[test]\n    fn test_aging_compensation() {\n        // New battery should have no change\n        assert_eq!(compensate_aging(50.0, 0.0, 0.02), 50.0);\n\n        // Aged battery should decrease SOC\n        let aged = compensate_aging(50.0, 5.0, 0.02);\n        assert!(aged \u003c 50.0, \"Aging should decrease SOC\");\n\n        // Test maximum 50% compensation\n        let very_aged = compensate_aging(50.0, 30.0, 0.02);\n        assert!(\n            very_aged \u003e= 25.0,\n            \"Should be limited to 50% max compensation\"\n        );\n    }\n\n    #[test]\n    fn test_temperature_compensation_different_coefficients() {\n        let base_soc = 50.0;\n        let temp = 0.0; // 25°C below nominal (cold)\n        let nominal = 25.0;\n\n        // Test with different temperature coefficients\n        // In cold conditions, higher coefficient = more capacity loss = lower SOC\n        let result1 = compensate_temperature(base_soc, temp, nominal, 0.005);\n        let result2 = compensate_temperature(base_soc, temp, nominal, 0.010);\n        let result3 = compensate_temperature(base_soc, temp, nominal, 0.001);\n\n        // Higher coefficient should result in MORE capacity loss (lower SOC) in cold\n        assert!(\n            result2 \u003c result1,\n            \"Higher coefficient should result in lower SOC in cold (more capacity loss)\"\n        );\n        assert!(\n            result3 \u003e result1,\n            \"Lower coefficient should result in higher SOC in cold (less capacity loss)\"\n        );\n    }\n\n    #[test]\n    fn test_temperature_compensation_different_nominal_temps() {\n        let base_soc = 50.0;\n        let temp = 0.0;\n        let coefficient = 0.0005;\n\n        // Test with different nominal temperatures\n        let result1 = compensate_temperature(base_soc, temp, 25.0, coefficient);\n        let result2 = compensate_temperature(base_soc, temp, 0.0, coefficient);\n\n        // When nominal temp equals actual temp, no compensation\n        let result3 = compensate_temperature(base_soc, 25.0, 25.0, coefficient);\n        assert_eq!(result3, base_soc, \"No compensation when temps are equal\");\n\n        // Different nominal temps should result in different compensation\n        assert!(\n            result1 != result2,\n            \"Different nominal temps should give different results\"\n        );\n    }\n\n    #[test]\n    fn test_aging_compensation_different_factors() {\n        let base_soc = 50.0;\n        let age = 5.0;\n\n        // Test with different aging factors\n        let result1 = compensate_aging(base_soc, age, 0.02);\n        let result2 = compensate_aging(base_soc, age, 0.05);\n        let result3 = compensate_aging(base_soc, age, 0.01);\n\n        // Higher aging factor should result in more reduction\n        assert!(\n            result2 \u003c result1,\n            \"Higher aging factor should reduce SOC more\"\n        );\n        assert!(\n            result3 \u003e result1,\n            \"Lower aging factor should reduce SOC less\"\n        );\n    }\n\n    #[test]\n    fn test_aging_compensation_different_ages() {\n        let base_soc = 50.0;\n        let factor = 0.02;\n\n        // Test with different battery ages\n        let result1 = compensate_aging(base_soc, 1.0, factor);\n        let result2 = compensate_aging(base_soc, 5.0, factor);\n        let result3 = compensate_aging(base_soc, 10.0, factor);\n\n        // Older battery should have lower SOC\n        assert!(result2 \u003c result1, \"Older battery should have lower SOC\");\n        assert!(\n            result3 \u003c result2,\n            \"Even older battery should have even lower SOC\"\n        );\n    }\n\n    #[test]\n    fn test_aging_compensation_zero_age() {\n        // Test that zero age results in no compensation\n        let result = compensate_aging(50.0, 0.0, 0.02);\n        assert_eq!(result, 50.0, \"Zero age should result in no compensation\");\n    }\n\n    #[test]\n    fn test_aging_compensation_max_limit() {\n        // Test that aging compensation is limited to 50%\n        let base_soc = 50.0;\n\n        // Very old battery with high aging factor\n        let result = compensate_aging(base_soc, 100.0, 1.0);\n\n        // Should be limited to 50% reduction (25.0)\n        assert!(result \u003e= 25.0, \"Should be limited to 50% max compensation\");\n    }\n\n    #[test]\n    fn test_temperature_compensation_max_limit() {\n        // Test that temperature compensation is limited to ±5%\n        let base_soc = 50.0;\n\n        // Extreme temperature difference\n        let cold_result = compensate_temperature(base_soc, -200.0, 25.0, 0.0005);\n        let hot_result = compensate_temperature(base_soc, 200.0, 25.0, 0.0005);\n\n        // Cold: should be at most 5% increase (52.5)\n        assert!(\n            cold_result \u003c= 52.5,\n            \"Cold compensation should be limited to +5%\"\n        );\n\n        // Hot: should be at most 5% decrease (47.5)\n        assert!(\n            hot_result \u003e= 47.5,\n            \"Hot compensation should be limited to -5%\"\n        );\n    }\n\n    #[test]\n    fn test_compensation_edge_cases() {\n        // Test compensation at boundary SOC values\n        let zero_soc = 0.0;\n        let full_soc = 100.0;\n\n        // Temperature compensation at 0% SOC\n        let temp_comp_zero = default_temperature_compensation(zero_soc, 0.0);\n        assert_eq!(temp_comp_zero, 0.0, \"0% SOC should remain 0%\");\n\n        // Temperature compensation at 100% SOC\n        let temp_comp_full = default_temperature_compensation(full_soc, 0.0);\n        assert!(temp_comp_full \u003c= 105.0, \"100% SOC should not exceed 105%\");\n\n        // Aging compensation at 0% SOC\n        let aging_comp_zero = compensate_aging(zero_soc, 5.0, 0.02);\n        assert_eq!(aging_comp_zero, 0.0, \"0% SOC should remain 0%\");\n\n        // Aging compensation at 100% SOC\n        let aging_comp_full = compensate_aging(full_soc, 5.0, 0.02);\n        assert!(aging_comp_full \u003c= 100.0, \"100% SOC should not exceed 100%\");\n    }\n\n    #[test]\n    fn test_temperature_compensation_fractional_values() {\n        // Test with fractional SOC values\n        let fractional_soc = 37.5;\n\n        let result = default_temperature_compensation(fractional_soc, 10.0);\n        assert!(result.is_finite(), \"Result should be finite\");\n        assert!(result \u003e= 0.0, \"Result should be non-negative\");\n    }\n\n    #[test]\n    fn test_aging_compensation_fractional_values() {\n        // Test with fractional age and factor values\n        let result = compensate_aging(50.0, 2.5, 0.015);\n        assert!(result.is_finite(), \"Result should be finite\");\n        assert!(result \u003e= 0.0, \"Result should be non-negative\");\n        assert!(result \u003c 50.0, \"Result should be less than base SOC\");\n    }\n\n    #[test]\n    fn test_compensation_negative_coefficient() {\n        // Test with negative temperature coefficient (unusual but possible)\n        let result = compensate_temperature(50.0, 0.0, 25.0, -0.0005);\n        assert!(result.is_finite(), \"Result should be finite\");\n    }\n\n    #[test]\n    fn test_compensation_zero_coefficient() {\n        // Test with zero coefficient (should result in no change)\n        let result = compensate_temperature(50.0, 0.0, 25.0, 0.0);\n        assert_eq!(result, 50.0, \"Zero coefficient should result in no change\");\n    }\n\n    #[test]\n    fn test_aging_compensation_zero_factor() {\n        // Test with zero aging factor (should result in no change)\n        let result = compensate_aging(50.0, 5.0, 0.0);\n        assert_eq!(result, 50.0, \"Zero aging factor should result in no change\");\n    }\n\n    #[test]\n    fn test_temperature_compensation_precision() {\n        // Test that compensation maintains reasonable precision\n        let base_soc = 50.123456;\n        let result = default_temperature_compensation(base_soc, 25.0);\n\n        // At nominal temperature, should be very close to original\n        assert!(\n            (result - base_soc).abs() \u003c 0.001,\n            \"Should maintain precision\"\n        );\n    }\n\n    #[test]\n    fn test_combined_compensation_effects() {\n        // Test that temperature and aging can be applied sequentially\n        let base_soc = 50.0;\n\n        // Apply temperature compensation\n        let temp_comp = default_temperature_compensation(base_soc, 0.0);\n\n        // Apply aging compensation to the result\n        let final_comp = compensate_aging(temp_comp, 5.0, 0.02);\n\n        // Both should have been applied\n        assert!(final_comp.is_finite(), \"Result should be finite\");\n        assert!(\n            (0.0..=100.0).contains(\u0026final_comp),\n            \"Result should be in valid range\"\n        );\n    }\n\n    #[test]\n    fn test_clamp_function() {\n        // Test clamping at upper bound (warm temperature, +5% max)\n        let result = compensate_temperature(50.0, 1000.0, 25.0, 0.005);\n        assert!(result \u003c= 52.5, \"Should be clamped to +5%\");\n\n        // Test clamping at lower bound (cold temperature, -30% max)\n        let result = compensate_temperature(50.0, -1000.0, 25.0, 0.005);\n        assert!(result \u003e= 35.0, \"Should be clamped to -30%\");\n\n        // Test that extreme cold is properly bounded\n        let result = compensate_temperature(50.0, -100.0, 25.0, 0.005);\n        assert!(result \u003e= 35.0, \"Extreme cold should be at lower bound\");\n    }\n}\n","traces":[{"line":57,"address":[478736],"length":1,"stats":{"Line":5},"fn_name":"compensate_temperature"},{"line":64,"address":[478788],"length":1,"stats":{"Line":5},"fn_name":null},{"line":65,"address":[478817],"length":1,"stats":{"Line":10},"fn_name":null},{"line":66,"address":[478834],"length":1,"stats":{"Line":10},"fn_name":null},{"line":67,"address":[478851],"length":1,"stats":{"Line":11},"fn_name":null},{"line":69,"address":[478803],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[478874],"length":1,"stats":{"Line":11},"fn_name":null},{"line":77,"address":[478890],"length":1,"stats":{"Line":11},"fn_name":null},{"line":79,"address":[478972],"length":1,"stats":{"Line":10},"fn_name":null},{"line":82,"address":[478923],"length":1,"stats":{"Line":3},"fn_name":null},{"line":87,"address":[478982],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[479024],"length":1,"stats":{"Line":13},"fn_name":null},{"line":128,"address":[478496],"length":1,"stats":{"Line":10},"fn_name":"compensate_aging"},{"line":130,"address":[478565,478536],"length":1,"stats":{"Line":19},"fn_name":null},{"line":131,"address":[478551],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[478599],"length":1,"stats":{"Line":9},"fn_name":null},{"line":136,"address":[478642],"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[478626],"length":1,"stats":{"Line":4},"fn_name":null},{"line":141,"address":[478727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[478662],"length":1,"stats":{"Line":7},"fn_name":null},{"line":145,"address":[478672],"length":1,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[479056],"length":1,"stats":{"Line":5},"fn_name":"default_temperature_compensation"},{"line":181,"address":[479068],"length":1,"stats":{"Line":5},"fn_name":null},{"line":195,"address":[479104],"length":1,"stats":{"Line":2},"fn_name":"clamp"},{"line":196,"address":[479126],"length":1,"stats":{"Line":20},"fn_name":null}],"covered":25,"coverable":25},{"path":["/","home","kingingwang","workspace","rust","battery-estimator","src","curve.rs"],"content":"//! Voltage-SOC curve definitions and interpolation\n//!\n//! This module provides the [`Curve`] struct for representing battery\n//! discharge curves and converting voltage measurements to state-of-charge (SOC) values.\n\nuse crate::{CurvePoint, Error};\n\n/// Maximum number of points allowed in a voltage curve\n///\n/// This limit ensures predictable memory usage and prevents excessive\n/// curve sizes that could impact performance in embedded systems.\npub const MAX_CURVE_POINTS: usize = 32;\n\n/// A voltage-to-SOC curve for battery state-of-charge estimation\n///\n/// This struct represents a discharge curve that maps battery voltage\n/// to state-of-charge percentage using linear interpolation between data points.\n///\n/// # Memory Optimization\n///\n/// The curve is stored using fixed-size arrays with optimized types:\n/// - `points`: Fixed array of 32 points\n/// - `len`: `u8` for point count (vs `usize`, saves memory)\n/// - `min_voltage_mv`/`max_voltage_mv`: `u16` for voltage limits\n/// - `min_soc_tenth`/`max_soc_tenth`: `u16` for cached SOC values (tenth of percent)\n///\n/// # Examples\n///\n/// ```no_run\n/// use battery_estimator::{Curve, CurvePoint};\n///\n/// // Create a custom curve\n/// const CUSTOM_CURVE: Curve = Curve::new(\u0026[\n///     CurvePoint::new(3.0, 0.0),\n///     CurvePoint::new(3.5, 50.0),\n///     CurvePoint::new(4.0, 100.0),\n/// ]);\n///\n/// // Use the curve\n/// match CUSTOM_CURVE.voltage_to_soc(3.75) {\n///     Ok(soc) =\u003e println!(\"SOC: {:.1}%\", soc),\n///     Err(e) =\u003e eprintln!(\"Error: {}\", e),\n/// }\n/// ```\n///\n/// # Interpolation\n///\n/// The curve uses linear interpolation between points:\n/// - Values at or below minimum voltage → Returns min SOC\n/// - Values at or above maximum voltage → Returns max SOC\n/// - Values between points → Linear interpolation\n#[derive(Debug, Clone, Copy)]\npub struct Curve {\n    /// Array of curve points (fixed size for memory efficiency)\n    points: [CurvePoint; MAX_CURVE_POINTS],\n\n    /// Number of points in the curve (0-255)\n    len: u8,\n\n    /// Minimum voltage in millivolts\n    min_voltage_mv: u16,\n\n    /// Maximum voltage in millivolts\n    max_voltage_mv: u16,\n\n    /// SOC at minimum voltage (cached in tenths of percent)\n    min_soc_tenth: u16,\n\n    /// SOC at maximum voltage (cached in tenths of percent)\n    max_soc_tenth: u16,\n}\n\nimpl Curve {\n    /// Creates an empty curve with no points\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use battery_estimator::Curve;\n    ///\n    /// let empty = Curve::empty();\n    /// assert!(empty.is_empty());\n    /// assert_eq!(empty.len(), 0);\n    /// ```\n    pub const fn empty() -\u003e Self {\n        Self {\n            points: [CurvePoint::new(0.0, 0.0); MAX_CURVE_POINTS],\n            len: 0,\n            min_voltage_mv: 0,\n            max_voltage_mv: 0,\n            min_soc_tenth: 0,\n            max_soc_tenth: 0,\n        }\n    }\n\n    /// Creates a new curve from a slice of points\n    ///\n    /// # Arguments\n    ///\n    /// * `points` - Slice of [`CurvePoint`] values, ordered by increasing voltage\n    ///\n    /// # Notes\n    ///\n    /// - Points must be ordered by increasing voltage\n    /// - Maximum of 32 points will be stored\n    /// - Minimum of 2 points required for valid interpolation\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use battery_estimator::{Curve, CurvePoint};\n    ///\n    /// let curve = Curve::new(\u0026[\n    ///     CurvePoint::new(3.0, 0.0),\n    ///     CurvePoint::new(3.5, 50.0),\n    ///     CurvePoint::new(4.0, 100.0),\n    /// ]);\n    /// ```\n    pub const fn new(points: \u0026[CurvePoint]) -\u003e Self {\n        let mut curve = Self::empty();\n        let mut i = 0usize;\n\n        let mut min = 0u16;\n        let mut max = 0u16;\n        let mut min_soc = 0u16;\n        let mut max_soc = 0u16;\n\n        while i \u003c points.len() \u0026\u0026 i \u003c MAX_CURVE_POINTS {\n            let p = points[i];\n            curve.points[i] = p;\n\n            if i == 0 {\n                min = p.voltage_mv;\n                max = p.voltage_mv;\n                min_soc = p.soc_tenth;\n                max_soc = p.soc_tenth;\n            } else {\n                if p.voltage_mv \u003c min {\n                    min = p.voltage_mv;\n                    min_soc = p.soc_tenth;\n                }\n                if p.voltage_mv \u003e max {\n                    max = p.voltage_mv;\n                    max_soc = p.soc_tenth;\n                }\n            }\n\n            i += 1;\n        }\n\n        curve.len = i as u8;\n        if i \u003e 0 {\n            curve.min_voltage_mv = min;\n            curve.max_voltage_mv = max;\n            curve.min_soc_tenth = min_soc;\n            curve.max_soc_tenth = max_soc;\n        }\n        curve\n    }\n\n    /// Converts a voltage measurement to state-of-charge (SOC) percentage\n    ///\n    /// # Arguments\n    ///\n    /// * `voltage` - Battery voltage in volts\n    ///\n    /// # Returns\n    ///\n    /// * `Ok(soc)` - SOC percentage (0.0 to 100.0)\n    /// * `Err(Error::InvalidCurve)` - Curve has fewer than 2 points\n    /// * `Err(Error::NumericalError)` - Division by zero or calculation error\n    ///\n    /// # Behavior\n    ///\n    /// - Voltage ≤ minimum → Returns min SOC\n    /// - Voltage ≥ maximum → Returns max SOC\n    /// - Voltage between points → Linear interpolation\n    ///\n    /// # Performance\n    ///\n    /// This method uses binary search (via `partition_point`) for O(log n) lookup\n    /// and cached SOC values for O(1) boundary checks.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use battery_estimator::{Curve, CurvePoint};\n    ///\n    /// let curve = Curve::new(\u0026[\n    ///     CurvePoint::new(3.0, 0.0),\n    ///     CurvePoint::new(3.5, 50.0),\n    ///     CurvePoint::new(4.0, 100.0),\n    /// ]);\n    ///\n    /// // At minimum voltage\n    /// assert_eq!(curve.voltage_to_soc(3.0).unwrap(), 0.0);\n    ///\n    /// // At maximum voltage\n    /// assert_eq!(curve.voltage_to_soc(4.0).unwrap(), 100.0);\n    ///\n    /// // Midpoint interpolation\n    /// assert_eq!(curve.voltage_to_soc(3.5).unwrap(), 50.0);\n    /// ```\n    pub fn voltage_to_soc(\u0026self, voltage: f32) -\u003e Result\u003cf32, Error\u003e {\n        if self.len \u003c 2 {\n            return Err(Error::InvalidCurve);\n        }\n\n        let voltage_mv = (voltage * 1000.0) as i32;\n\n        // Boundary checks - use cached SOC values for O(1) lookup\n        if voltage_mv \u003e= self.max_voltage_mv as i32 {\n            return Ok(self.max_soc_tenth as f32 / 10.0);\n        }\n        if voltage_mv \u003c= self.min_voltage_mv as i32 {\n            return Ok(self.min_soc_tenth as f32 / 10.0);\n        }\n\n        // Binary search for interpolation segment using Rust's partition_point\n        let points = \u0026self.points[..self.len as usize];\n\n        // Find the index of the first point with voltage \u003e target voltage\n        let idx = points.partition_point(|p| p.voltage_mv as i32 \u003c= voltage_mv);\n\n        // Check if we found a valid interpolation segment\n        if idx \u003e 0 \u0026\u0026 idx \u003c points.len() {\n            let prev = points[idx - 1];\n            let curr = points[idx];\n\n            if voltage_mv \u003e= prev.voltage_mv as i32 \u0026\u0026 voltage_mv \u003c= curr.voltage_mv as i32 {\n                let range = (curr.voltage_mv as i32 - prev.voltage_mv as i32) as f32;\n                let ratio = (voltage_mv - prev.voltage_mv as i32) as f32 / range;\n                let soc = prev.soc() + ratio * (curr.soc() - prev.soc());\n                return Ok(soc);\n            }\n        }\n\n        Err(Error::NumericalError)\n    }\n\n    /// Returns the voltage range of the curve\n    ///\n    /// # Returns\n    ///\n    /// Tuple of (minimum_voltage, maximum_voltage) in volts\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use battery_estimator::{Curve, CurvePoint};\n    ///\n    /// let curve = Curve::new(\u0026[\n    ///     CurvePoint::new(3.0, 0.0),\n    ///     CurvePoint::new(4.0, 100.0),\n    /// ]);\n    ///\n    /// let (min, max) = curve.voltage_range();\n    /// assert_eq!(min, 3.0);\n    /// assert_eq!(max, 4.0);\n    /// ```\n    #[inline]\n    pub const fn voltage_range(\u0026self) -\u003e (f32, f32) {\n        (\n            self.min_voltage_mv as f32 / 1000.0,\n            self.max_voltage_mv as f32 / 1000.0,\n        )\n    }\n\n    /// Returns the number of points in the curve\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use battery_estimator::{Curve, CurvePoint};\n    ///\n    /// let curve = Curve::new(\u0026[\n    ///     CurvePoint::new(3.0, 0.0),\n    ///     CurvePoint::new(3.5, 50.0),\n    ///     CurvePoint::new(4.0, 100.0),\n    /// ]);\n    ///\n    /// assert_eq!(curve.len(), 3);\n    /// ```\n    #[inline]\n    pub const fn len(\u0026self) -\u003e usize {\n        self.len as usize\n    }\n\n    /// Returns `true` if the curve has no points\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use battery_estimator::Curve;\n    ///\n    /// let empty = Curve::empty();\n    /// assert!(empty.is_empty());\n    /// ```\n    #[inline]\n    pub const fn is_empty(\u0026self) -\u003e bool {\n        self.len == 0\n    }\n}\n\n/// Predefined battery voltage curves\n///\n/// This module contains built-in voltage curves for common battery types.\n/// These curves are optimized for typical discharge characteristics.\npub mod default_curves {\n    use super::*;\n\n    /// Standard Lithium Polymer (LiPo) battery curve\n    ///\n    /// - Full charge: 4.2V\n    /// - Cutoff: 3.2V\n    /// - Nominal: 3.7V\n    /// - Points: 10\n    pub const LIPO: Curve = Curve::new(\u0026[\n        CurvePoint::new(3.20, 0.0),\n        CurvePoint::new(3.30, 5.0),\n        CurvePoint::new(3.40, 10.0),\n        CurvePoint::new(3.50, 20.0),\n        CurvePoint::new(3.60, 30.0),\n        CurvePoint::new(3.70, 50.0),\n        CurvePoint::new(3.80, 70.0),\n        CurvePoint::new(3.90, 85.0),\n        CurvePoint::new(4.00, 95.0),\n        CurvePoint::new(4.20, 100.0),\n    ]);\n\n    /// Lithium Iron Phosphate (LiFePO4) battery curve\n    ///\n    /// - Full charge: 3.65V\n    /// - Cutoff: 3.0V\n    /// - Nominal: 3.2V\n    /// - Points: 10\n    /// - Features: Very flat discharge curve, long cycle life\n    pub const LIFEPO4: Curve = Curve::new(\u0026[\n        CurvePoint::new(2.50, 0.0),\n        CurvePoint::new(2.80, 15.0),\n        CurvePoint::new(3.00, 35.0),\n        CurvePoint::new(3.10, 45.0),\n        CurvePoint::new(3.20, 55.0),\n        CurvePoint::new(3.30, 65.0),\n        CurvePoint::new(3.40, 75.0),\n        CurvePoint::new(3.50, 85.0),\n        CurvePoint::new(3.60, 95.0),\n        CurvePoint::new(3.65, 100.0),\n    ]);\n\n    /// Standard Lithium Ion (Li-Ion) battery curve\n    ///\n    /// - Full charge: 4.2V\n    /// - Cutoff: 3.3V\n    /// - Nominal: 3.7V\n    /// - Points: 11\n    pub const LIION: Curve = Curve::new(\u0026[\n        CurvePoint::new(2.50, 0.0),\n        CurvePoint::new(3.00, 30.0),\n        CurvePoint::new(3.30, 50.0),\n        CurvePoint::new(3.50, 65.0),\n        CurvePoint::new(3.60, 70.0),\n        CurvePoint::new(3.70, 75.0),\n        CurvePoint::new(3.80, 80.0),\n        CurvePoint::new(3.90, 85.0),\n        CurvePoint::new(4.00, 90.0),\n        CurvePoint::new(4.10, 95.0),\n        CurvePoint::new(4.20, 100.0),\n    ]);\n\n    /// Conservative LiPo curve for extended battery life\n    ///\n    /// - Full charge: 4.1V (lower than standard 4.2V)\n    /// - Cutoff: 3.4V (higher than standard 3.2V)\n    /// - Nominal: 3.77V\n    /// - Points: 13\n    ///\n    /// # Use Case\n    ///\n    /// This curve prioritizes battery longevity over maximum capacity:\n    /// - **Lower charge voltage** (4.1V) reduces charging stress\n    /// - **Higher cutoff** (3.4V) prevents deep discharge\n    /// - **Trade-off**: ~15-20% less usable capacity for ~30% longer cycle life\n    ///\n    /// # When to Use\n    ///\n    /// - Applications where battery replacement is difficult\n    /// - Devices requiring very long service life\n    /// - Systems prioritizing reliability over runtime\n    pub const LIPO410_FULL340_CUTOFF: Curve = Curve::new(\u0026[\n        CurvePoint::new(3.40, 0.0),\n        CurvePoint::new(3.48, 5.0),\n        CurvePoint::new(3.53, 10.0),\n        CurvePoint::new(3.62, 20.0),\n        CurvePoint::new(3.68, 30.0),\n        CurvePoint::new(3.73, 40.0),\n        CurvePoint::new(3.77, 50.0),\n        CurvePoint::new(3.81, 60.0),\n        CurvePoint::new(3.85, 70.0),\n        CurvePoint::new(3.90, 80.0),\n        CurvePoint::new(3.97, 90.0),\n        CurvePoint::new(4.03, 95.0),\n        CurvePoint::new(4.10, 100.0),\n    ]);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_curve_basic() {\n        let curve = Curve::new(\u0026[CurvePoint::new(3.0, 0.0), CurvePoint::new(4.0, 100.0)]);\n\n        assert_eq!(curve.voltage_to_soc(3.0).unwrap(), 0.0);\n        assert_eq!(curve.voltage_to_soc(4.0).unwrap(), 100.0);\n        assert_eq!(curve.voltage_to_soc(3.5).unwrap(), 50.0);\n    }\n\n    #[test]\n    fn test_curve_boundaries() {\n        let curve = Curve::new(\u0026[\n            CurvePoint::new(3.0, 0.0),\n            CurvePoint::new(3.5, 50.0),\n            CurvePoint::new(4.0, 100.0),\n        ]);\n\n        // Test boundaries\n        assert_eq!(curve.voltage_to_soc(2.9).unwrap(), 0.0);\n        assert_eq!(curve.voltage_to_soc(4.1).unwrap(), 100.0);\n\n        // Test intermediate values\n        assert_eq!(curve.voltage_to_soc(3.25).unwrap(), 25.0);\n        assert_eq!(curve.voltage_to_soc(3.75).unwrap(), 75.0);\n    }\n\n    #[test]\n    fn test_curve_invalid() {\n        let curve = Curve::new(\u0026[CurvePoint::new(3.0, 0.0)]);\n\n        // Curve with only one point should error\n        assert!(curve.voltage_to_soc(3.5).is_err());\n    }\n\n    #[test]\n    fn test_curve_empty() {\n        let curve = Curve::empty();\n        assert!(curve.is_empty());\n        assert_eq!(curve.len(), 0);\n        assert!(curve.voltage_to_soc(3.0).is_err());\n    }\n\n    #[test]\n    fn test_curve_multiple_points() {\n        let curve = Curve::new(\u0026[\n            CurvePoint::new(3.0, 0.0),\n            CurvePoint::new(3.5, 50.0),\n            CurvePoint::new(4.0, 100.0),\n        ]);\n\n        assert_eq!(curve.len(), 3);\n\n        // Test exact points\n        assert_eq!(curve.voltage_to_soc(3.0).unwrap(), 0.0);\n        assert_eq!(curve.voltage_to_soc(3.5).unwrap(), 50.0);\n        assert_eq!(curve.voltage_to_soc(4.0).unwrap(), 100.0);\n\n        // Test interpolation\n        let soc = curve.voltage_to_soc(3.25).unwrap();\n        assert!((soc - 25.0).abs() \u003c 0.1);\n\n        let soc = curve.voltage_to_soc(3.75).unwrap();\n        assert!((soc - 75.0).abs() \u003c 0.1);\n    }\n\n    #[test]\n    fn test_curve_voltage_range() {\n        let curve = Curve::new(\u0026[CurvePoint::new(3.0, 0.0), CurvePoint::new(4.0, 100.0)]);\n\n        let (min, max) = curve.voltage_range();\n        assert_eq!(min, 3.0);\n        assert_eq!(max, 4.0);\n    }\n\n    #[test]\n    fn test_curve_max_points() {\n        // Test that curve handles maximum number of points\n        let mut points = [CurvePoint::new(0.0, 0.0); MAX_CURVE_POINTS];\n        for (i, point) in points.iter_mut().enumerate().take(MAX_CURVE_POINTS) {\n            let voltage = 3.0 + (i as f32 * 0.1);\n            let soc = (i as f32 / (MAX_CURVE_POINTS - 1) as f32) * 100.0;\n            *point = CurvePoint::new(voltage, soc);\n        }\n\n        let curve = Curve::new(\u0026points);\n        assert_eq!(curve.len(), MAX_CURVE_POINTS);\n\n        // Test interpolation at various points\n        assert!(curve.voltage_to_soc(3.5).is_ok());\n    }\n\n    #[test]\n    fn test_curve_numerical_error_fallback() {\n        // Test the fallback NumericalError path when voltage is not found in any segment\n        // This can happen with non-monotonic/decreasing voltage curves\n        // The curve stores points in order, but with decreasing voltages\n        // so the linear search won't find a valid segment\n        let curve = Curve::new(\u0026[\n            CurvePoint::new(3.0, 0.0),\n            CurvePoint::new(2.5, 50.0), // Decreasing voltage\n            CurvePoint::new(2.0, 100.0),\n        ]);\n\n        // Voltage 2.7 is between 3.0 and 2.5 but not in increasing order\n        // This should trigger NumericalError\n        assert!(matches!(\n            curve.voltage_to_soc(2.7),\n            Err(Error::NumericalError)\n        ));\n    }\n\n    #[test]\n    fn test_curve_cached_soc_values() {\n        // Test that cached SOC values are correctly computed\n        let curve = Curve::new(\u0026[\n            CurvePoint::new(3.0, 5.0), // Non-zero min SOC\n            CurvePoint::new(3.5, 50.0),\n            CurvePoint::new(4.0, 95.0), // Non-100 max SOC\n        ]);\n\n        // At min voltage, should return cached min SOC (5.0%)\n        assert_eq!(curve.voltage_to_soc(3.0).unwrap(), 5.0);\n\n        // Below min voltage, should still return cached min SOC\n        assert_eq!(curve.voltage_to_soc(2.5).unwrap(), 5.0);\n\n        // At max voltage, should return cached max SOC (95.0%)\n        assert_eq!(curve.voltage_to_soc(4.0).unwrap(), 95.0);\n\n        // Above max voltage, should still return cached max SOC\n        assert_eq!(curve.voltage_to_soc(4.5).unwrap(), 95.0);\n    }\n\n    #[test]\n    fn test_curve_interpolation_precision() {\n        let curve = Curve::new(\u0026[\n            CurvePoint::new(3.0, 0.0),\n            CurvePoint::new(3.1, 10.0),\n            CurvePoint::new(3.2, 20.0),\n            CurvePoint::new(3.3, 30.0),\n        ]);\n\n        // Test precise interpolation\n        assert_eq!(curve.voltage_to_soc(3.05).unwrap(), 5.0);\n        assert_eq!(curve.voltage_to_soc(3.15).unwrap(), 15.0);\n        assert_eq!(curve.voltage_to_soc(3.25).unwrap(), 25.0);\n    }\n\n    #[test]\n    fn test_curve_single_segment() {\n        let curve = Curve::new(\u0026[CurvePoint::new(3.0, 0.0), CurvePoint::new(4.0, 100.0)]);\n\n        // Single segment interpolation\n        assert_eq!(curve.voltage_to_soc(3.25).unwrap(), 25.0);\n        assert_eq!(curve.voltage_to_soc(3.5).unwrap(), 50.0);\n        assert_eq!(curve.voltage_to_soc(3.75).unwrap(), 75.0);\n    }\n\n    #[test]\n    fn test_curve_dense_points() {\n        // Test with many closely spaced points - use array for no_std compatibility\n        let points: [CurvePoint; 21] =\n            core::array::from_fn(|i| CurvePoint::new(3.0 + i as f32 * 0.05, i as f32 * 5.0));\n\n        let curve = Curve::new(\u0026points);\n\n        // Test that interpolation works with dense points\n        for i in 0..20 {\n            let voltage = 3.0 + i as f32 * 0.05 + 0.025;\n            let expected_soc = i as f32 * 5.0 + 2.5;\n            assert!((curve.voltage_to_soc(voltage).unwrap() - expected_soc).abs() \u003c 0.01);\n        }\n    }\n\n    #[test]\n    fn test_curve_non_linear() {\n        // Test with non-linear curve (exponential-like)\n        let curve = Curve::new(\u0026[\n            CurvePoint::new(3.0, 0.0),\n            CurvePoint::new(3.5, 20.0),\n            CurvePoint::new(4.0, 60.0),\n            CurvePoint::new(4.2, 100.0),\n        ]);\n\n        // Verify non-linear interpolation\n        let soc_35 = curve.voltage_to_soc(3.5).unwrap();\n        let soc_38 = curve.voltage_to_soc(3.8).unwrap();\n        let soc_41 = curve.voltage_to_soc(4.1).unwrap();\n\n        assert_eq!(soc_35, 20.0);\n        // 3.8V is between 3.5V (20%) and 4.0V (60%)\n        // ratio = (3.8 - 3.5) / (4.0 - 3.5) = 0.6\n        // soc = 20 + 0.6 * 40 = 44.0\n        assert!((soc_38 - 44.0).abs() \u003c 0.1);\n        // 4.1V is between 4.0V (60%) and 4.2V (100%)\n        // ratio = (4.1 - 4.0) / (4.2 - 4.0) = 0.5\n        // soc = 60 + 0.5 * 40 = 80.0\n        assert!((soc_41 - 80.0).abs() \u003c 0.1);\n    }\n}\n","traces":[{"line":85,"address":[455200],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[455217],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[454560],"length":1,"stats":{"Line":12},"fn_name":null},{"line":120,"address":[454603],"length":1,"stats":{"Line":12},"fn_name":null},{"line":121,"address":[454613],"length":1,"stats":{"Line":12},"fn_name":null},{"line":123,"address":[454625],"length":1,"stats":{"Line":12},"fn_name":null},{"line":124,"address":[454635],"length":1,"stats":{"Line":12},"fn_name":null},{"line":125,"address":[454645],"length":1,"stats":{"Line":12},"fn_name":null},{"line":126,"address":[454655],"length":1,"stats":{"Line":8},"fn_name":null},{"line":128,"address":[454670,454708,455168],"length":1,"stats":{"Line":36},"fn_name":null},{"line":129,"address":[454856,454922,454724],"length":1,"stats":{"Line":24},"fn_name":null},{"line":130,"address":[454950,454978,454891],"length":1,"stats":{"Line":24},"fn_name":null},{"line":132,"address":[454960,455038],"length":1,"stats":{"Line":24},"fn_name":null},{"line":133,"address":[455006],"length":1,"stats":{"Line":12},"fn_name":null},{"line":134,"address":[455014],"length":1,"stats":{"Line":12},"fn_name":null},{"line":135,"address":[455022],"length":1,"stats":{"Line":12},"fn_name":null},{"line":136,"address":[455030],"length":1,"stats":{"Line":12},"fn_name":null},{"line":138,"address":[455045,455126],"length":1,"stats":{"Line":12},"fn_name":null},{"line":139,"address":[455110],"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[455118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[455088,455154],"length":1,"stats":{"Line":20},"fn_name":null},{"line":143,"address":[455138],"length":1,"stats":{"Line":10},"fn_name":null},{"line":144,"address":[455146],"length":1,"stats":{"Line":10},"fn_name":null},{"line":148,"address":[455173,455160,455057],"length":1,"stats":{"Line":24},"fn_name":null},{"line":151,"address":[454680],"length":1,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[454844,454695],"length":1,"stats":{"Line":13},"fn_name":null},{"line":153,"address":[454780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[454796],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[454812],"length":1,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[454828],"length":1,"stats":{"Line":12},"fn_name":null},{"line":158,"address":[454752],"length":1,"stats":{"Line":12},"fn_name":null},{"line":204,"address":[453744],"length":1,"stats":{"Line":4},"fn_name":null},{"line":205,"address":[453773],"length":1,"stats":{"Line":5},"fn_name":null},{"line":206,"address":[453855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[453793],"length":1,"stats":{"Line":5},"fn_name":null},{"line":212,"address":[453840],"length":1,"stats":{"Line":5},"fn_name":null},{"line":213,"address":[453899],"length":1,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[453875],"length":1,"stats":{"Line":5},"fn_name":null},{"line":216,"address":[454026],"length":1,"stats":{"Line":2},"fn_name":null},{"line":220,"address":[453943],"length":1,"stats":{"Line":3},"fn_name":null},{"line":223,"address":[521498,521488],"length":1,"stats":{"Line":16},"fn_name":"{closure#0}"},{"line":226,"address":[454090,454013],"length":1,"stats":{"Line":12},"fn_name":null},{"line":227,"address":[454100,454204],"length":1,"stats":{"Line":6},"fn_name":null},{"line":228,"address":[454272,454227,454187],"length":1,"stats":{"Line":12},"fn_name":null},{"line":230,"address":[454246,454285],"length":1,"stats":{"Line":12},"fn_name":null},{"line":231,"address":[454340,454385,454300],"length":1,"stats":{"Line":12},"fn_name":null},{"line":232,"address":[454359,454408,454531],"length":1,"stats":{"Line":12},"fn_name":null},{"line":233,"address":[454431],"length":1,"stats":{"Line":6},"fn_name":null},{"line":234,"address":[454515],"length":1,"stats":{"Line":6},"fn_name":null},{"line":238,"address":[454065],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[453696],"length":1,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[453701],"length":1,"stats":{"Line":2},"fn_name":null},{"line":265,"address":[453724],"length":1,"stats":{"Line":3},"fn_name":null},{"line":285,"address":[454544],"length":1,"stats":{"Line":1},"fn_name":null},{"line":286,"address":[454549],"length":1,"stats":{"Line":1},"fn_name":null},{"line":300,"address":[455376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":301,"address":[455381],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":57,"coverable":57},{"path":["/","home","kingingwang","workspace","rust","battery-estimator","src","error.rs"],"content":"//! Error types for battery SOC estimation\n//!\n//! This module defines the error types that can occur during battery\n//! state-of-charge estimation operations.\n\nuse thiserror::Error;\n\n/// Errors that can occur during battery SOC estimation\n///\n/// This enum represents all possible error conditions that may arise\n/// when using the battery estimator library.\n///\n/// # Examples\n///\n/// ```no_run\n/// use battery_estimator::{BatteryChemistry, SocEstimator, Error};\n///\n/// let estimator = SocEstimator::new(BatteryChemistry::LiPo);\n///\n/// match estimator.estimate_soc(3.7) {\n///     Ok(soc) =\u003e println!(\"SOC: {:.1}%\", soc),\n///     Err(Error::InvalidCurve) =\u003e eprintln!(\"Invalid battery curve\"),\n///     Err(Error::NumericalError) =\u003e eprintln!(\"Calculation error\"),\n///     Err(Error::InvalidTemperature) =\u003e eprintln!(\"Invalid temperature\"),\n/// }\n/// ```\n#[derive(Error, Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub enum Error {\n    /// The voltage curve data is invalid\n    ///\n    /// This error occurs when:\n    /// - The curve has fewer than 2 points (cannot interpolate)\n    /// - The curve points are not properly ordered\n    /// - The curve has duplicate voltage values\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use battery_estimator::{Curve, CurvePoint, Error};\n    ///\n    /// // Invalid: Only one point\n    /// let invalid_curve = Curve::new(\u0026[CurvePoint::new(3.7, 50.0)]);\n    /// let result = invalid_curve.voltage_to_soc(3.7);\n    /// assert!(matches!(result, Err(Error::InvalidCurve)));\n    /// ```\n    #[error(\"Invalid voltage curve\")]\n    InvalidCurve,\n\n    /// A numerical error occurred during calculation\n    ///\n    /// This error occurs when:\n    /// - Division by zero in interpolation\n    /// - Overflow or underflow in calculations\n    /// - Invalid floating-point operations\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use battery_estimator::{Curve, CurvePoint, Error};\n    ///\n    /// // This could occur if curve points have the same voltage\n    /// let problematic_curve = Curve::new(\u0026[\n    ///     CurvePoint::new(3.7, 50.0),\n    ///     CurvePoint::new(3.7, 60.0), // Duplicate voltage!\n    /// ]);\n    /// ```\n    #[error(\"Numerical error in calculation\")]\n    NumericalError,\n\n    /// The temperature value is invalid\n    ///\n    /// This error occurs when:\n    /// - Temperature is NaN (Not a Number)\n    /// - Temperature is infinity\n    /// - Temperature is outside reasonable bounds\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use battery_estimator::{BatteryChemistry, SocEstimator, Error};\n    ///\n    /// let estimator = SocEstimator::new(BatteryChemistry::LiPo);\n    ///\n    /// // Invalid temperature\n    /// let result = estimator.estimate_soc_with_temp(3.7, f32::NAN);\n    /// ```\n    #[error(\"Invalid temperature\")]\n    InvalidTemperature,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::fmt::Write;\n\n    #[test]\n    fn test_error_display() {\n        // In no-std, Display is available via core::fmt\n        // We can test that the Display implementation compiles and works\n        let mut buffer = [0u8; 64];\n\n        // Test InvalidCurve\n        let mut writer = BufferWriter::new(\u0026mut buffer);\n        write!(writer, \"{}\", Error::InvalidCurve).unwrap();\n        assert_eq!(writer.as_str(), \"Invalid voltage curve\");\n\n        // Test NumericalError\n        let mut writer = BufferWriter::new(\u0026mut buffer);\n        write!(writer, \"{}\", Error::NumericalError).unwrap();\n        assert_eq!(writer.as_str(), \"Numerical error in calculation\");\n\n        // Test InvalidTemperature\n        let mut writer = BufferWriter::new(\u0026mut buffer);\n        write!(writer, \"{}\", Error::InvalidTemperature).unwrap();\n        assert_eq!(writer.as_str(), \"Invalid temperature\");\n    }\n\n    #[test]\n    fn test_error_equality() {\n        assert_eq!(Error::InvalidCurve, Error::InvalidCurve);\n        assert_eq!(Error::NumericalError, Error::NumericalError);\n        assert_eq!(Error::InvalidTemperature, Error::InvalidTemperature);\n\n        assert_ne!(Error::InvalidCurve, Error::NumericalError);\n    }\n\n    #[test]\n    fn test_error_copy() {\n        let error1 = Error::InvalidCurve;\n        let error2 = error1;\n        assert_eq!(error1, error2);\n    }\n\n    #[test]\n    fn test_error_debug() {\n        let error = Error::NumericalError;\n        let mut buffer = [0u8; 64];\n        let mut writer = BufferWriter::new(\u0026mut buffer);\n        write!(writer, \"{:?}\", error).unwrap();\n        assert!(writer.as_str().contains(\"NumericalError\"));\n    }\n\n    #[test]\n    fn test_error_all_variants() {\n        // Test that all error variants can be created\n        let errors = [\n            Error::InvalidCurve,\n            Error::NumericalError,\n            Error::InvalidTemperature,\n        ];\n        assert_eq!(errors.len(), 3);\n    }\n\n    #[test]\n    fn test_error_variants_distinct() {\n        let error1 = Error::InvalidCurve;\n        let error2 = Error::NumericalError;\n        let error3 = Error::InvalidTemperature;\n\n        // Verify all variants are distinct\n        assert_ne!(error1, error2);\n        assert_ne!(error2, error3);\n        assert_ne!(error1, error3);\n    }\n\n    // Helper struct for testing Display in no-std\n    struct BufferWriter\u003c'a\u003e {\n        buffer: \u0026'a mut [u8],\n        pos: usize,\n    }\n\n    impl\u003c'a\u003e BufferWriter\u003c'a\u003e {\n        fn new(buffer: \u0026'a mut [u8]) -\u003e Self {\n            BufferWriter { buffer, pos: 0 }\n        }\n\n        fn as_str(\u0026self) -\u003e \u0026str {\n            core::str::from_utf8(\u0026self.buffer[..self.pos]).unwrap()\n        }\n    }\n\n    impl\u003c'a\u003e core::fmt::Write for BufferWriter\u003c'a\u003e {\n        fn write_str(\u0026mut self, s: \u0026str) -\u003e core::fmt::Result {\n            let bytes = s.as_bytes();\n            if self.pos + bytes.len() \u003e self.buffer.len() {\n                return Err(core::fmt::Error);\n            }\n            self.buffer[self.pos..self.pos + bytes.len()].copy_from_slice(bytes);\n            self.pos += bytes.len();\n            Ok(())\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kingingwang","workspace","rust","battery-estimator","src","estimator.rs"],"content":"//! SOC (State of Charge) Estimator with Temperature Compensation\n\nuse crate::{\n    compensate_aging, compensate_temperature, default_curves, default_temperature_compensation,\n    BatteryChemistry, Curve, Error,\n};\n\n/// SOC estimator configuration\n#[repr(C)]\n#[derive(Debug, Clone, Copy)]\npub struct EstimatorConfig {\n    /// Nominal temperature (°C)\n    pub nominal_temperature: f32,\n    /// Temperature compensation coefficient (percentage change per °C)\n    pub temperature_coefficient: f32,\n    /// Battery age (years)\n    pub age_years: f32,\n    /// Aging factor (capacity loss percentage per year)\n    pub aging_factor: f32,\n    /// Compensation flags (bit field compression)\n    flags: u8,\n}\n\nimpl EstimatorConfig {\n    /// Default configuration\n    #[inline]\n    pub const fn default() -\u003e Self {\n        Self {\n            nominal_temperature: 25.0,\n            temperature_coefficient: 0.005, // 0.5% per °C (matches default_temperature_compensation)\n            age_years: 0.0,\n            aging_factor: 0.02, // 2% capacity loss per year\n            flags: 0,\n        }\n    }\n\n    /// Enable temperature compensation\n    #[inline]\n    pub const fn with_temperature_compensation(mut self) -\u003e Self {\n        self.flags |= 0x01;\n        self\n    }\n\n    /// Enable aging compensation\n    #[inline]\n    pub const fn with_aging_compensation(mut self) -\u003e Self {\n        self.flags |= 0x02;\n        self\n    }\n\n    /// Set nominal temperature\n    #[inline]\n    pub const fn with_nominal_temperature(mut self, temp: f32) -\u003e Self {\n        self.nominal_temperature = temp;\n        self\n    }\n\n    /// Set temperature coefficient\n    #[inline]\n    pub const fn with_temperature_coefficient(mut self, coeff: f32) -\u003e Self {\n        self.temperature_coefficient = coeff;\n        self\n    }\n\n    /// Set battery age\n    #[inline]\n    pub const fn with_age_years(mut self, years: f32) -\u003e Self {\n        self.age_years = years;\n        self\n    }\n\n    /// Set aging factor\n    #[inline]\n    pub const fn with_aging_factor(mut self, factor: f32) -\u003e Self {\n        self.aging_factor = factor;\n        self\n    }\n\n    /// Returns `true` if temperature compensation is enabled\n    pub const fn is_temperature_compensation_enabled(self) -\u003e bool {\n        (self.flags \u0026 0x01) != 0\n    }\n\n    /// Returns `true` if aging compensation is enabled\n    pub const fn is_aging_compensation_enabled(self) -\u003e bool {\n        (self.flags \u0026 0x02) != 0\n    }\n}\n\n// Non-const Default implementation\nimpl Default for EstimatorConfig {\n    #[inline]\n    fn default() -\u003e Self {\n        Self::default()\n    }\n}\n\n/// SOC estimator\n#[derive(Debug, Clone, Copy)]\npub struct SocEstimator {\n    curve: \u0026'static Curve,\n    config: EstimatorConfig,\n}\n\nimpl SocEstimator {\n    /// Create a new SOC estimator (default configuration)\n    pub const fn new(chemistry: BatteryChemistry) -\u003e Self {\n        let curve = match chemistry {\n            BatteryChemistry::LiPo =\u003e \u0026default_curves::LIPO,\n            BatteryChemistry::LiFePO4 =\u003e \u0026default_curves::LIFEPO4,\n            BatteryChemistry::LiIon =\u003e \u0026default_curves::LIION,\n            BatteryChemistry::Lipo410Full340Cutoff =\u003e \u0026default_curves::LIPO410_FULL340_CUTOFF,\n        };\n\n        Self {\n            curve,\n            config: EstimatorConfig::default(), // This is now a const function\n        }\n    }\n\n    /// Create estimator with custom curve\n    pub const fn with_custom_curve(curve: \u0026'static Curve) -\u003e Self {\n        Self {\n            curve,\n            config: EstimatorConfig::default(),\n        }\n    }\n\n    /// Create estimator with configuration (const version)\n    pub const fn with_config(chemistry: BatteryChemistry, config: EstimatorConfig) -\u003e Self {\n        let curve = match chemistry {\n            BatteryChemistry::LiPo =\u003e \u0026default_curves::LIPO,\n            BatteryChemistry::LiFePO4 =\u003e \u0026default_curves::LIFEPO4,\n            BatteryChemistry::LiIon =\u003e \u0026default_curves::LIION,\n            BatteryChemistry::Lipo410Full340Cutoff =\u003e \u0026default_curves::LIPO410_FULL340_CUTOFF,\n        };\n\n        Self { curve, config }\n    }\n\n    /// Estimate SOC (without temperature compensation)\n    pub fn estimate_soc(\u0026self, voltage: f32) -\u003e Result\u003cf32, Error\u003e {\n        self.curve.voltage_to_soc(voltage)\n    }\n\n    /// Estimate SOC with default temperature compensation (ignores configuration)\n    ///\n    /// This method always applies temperature compensation using default parameters\n    /// (nominal temperature: 25°C, coefficient: 0.005), regardless of the estimator's\n    /// current configuration. For configuration-based compensation, use\n    /// `estimate_soc_compensated()` instead.\n    ///\n    /// # Arguments\n    ///\n    /// * `voltage` - Battery voltage in volts\n    /// * `temperature` - Current battery temperature in Celsius\n    ///\n    /// # Returns\n    ///\n    /// Temperature-compensated SOC percentage using default parameters\n    pub fn estimate_soc_with_temp(\u0026self, voltage: f32, temperature: f32) -\u003e Result\u003cf32, Error\u003e {\n        let base_soc = self.curve.voltage_to_soc(voltage)?;\n\n        // Always apply temperature compensation with default parameters\n        let compensated = default_temperature_compensation(base_soc, temperature);\n\n        Ok(compensated.clamp(0.0, 100.0))\n    }\n\n    /// Estimate SOC (using configuration settings)\n    pub fn estimate_soc_compensated(\u0026self, voltage: f32, temperature: f32) -\u003e Result\u003cf32, Error\u003e {\n        let base_soc = self.curve.voltage_to_soc(voltage)?;\n        let mut soc = base_soc;\n\n        // Apply temperature compensation\n        if EstimatorConfig::is_temperature_compensation_enabled(self.config) {\n            soc = compensate_temperature(\n                soc,\n                temperature,\n                self.config.nominal_temperature,\n                self.config.temperature_coefficient,\n            );\n        }\n\n        // Apply aging compensation\n        if EstimatorConfig::is_aging_compensation_enabled(self.config) {\n            soc = compensate_aging(soc, self.config.age_years, self.config.aging_factor);\n        }\n\n        // Ensure SOC is within valid range\n        Ok(soc.clamp(0.0, 100.0))\n    }\n\n    /// Get voltage range\n    pub const fn voltage_range(\u0026self) -\u003e (f32, f32) {\n        self.curve.voltage_range()\n    }\n\n    /// Update configuration\n    #[inline]\n    pub fn update_config(\u0026mut self, config: EstimatorConfig) {\n        self.config = config;\n    }\n\n    /// Get current configuration\n    #[inline]\n    pub const fn config(\u0026self) -\u003e \u0026EstimatorConfig {\n        \u0026self.config\n    }\n\n    /// Enable temperature compensation\n    pub fn enable_temperature_compensation(\u0026mut self, nominal_temp: f32, coefficient: f32) {\n        self.config = self\n            .config\n            .with_temperature_compensation()\n            .with_nominal_temperature(nominal_temp)\n            .with_temperature_coefficient(coefficient);\n    }\n\n    /// Enable aging compensation\n    pub fn enable_aging_compensation(\u0026mut self, age_years: f32, aging_factor: f32) {\n        self.config = self\n            .config\n            .with_aging_compensation()\n            .with_age_years(age_years)\n            .with_aging_factor(aging_factor);\n    }\n\n    /// Disable all compensation\n    pub fn disable_all_compensation(\u0026mut self) {\n        self.config = EstimatorConfig::default();\n    }\n}\n\n// Convenience constructors for simplified usage\nimpl SocEstimator {\n    /// Create estimator with temperature compensation\n    #[inline]\n    pub fn with_temperature_compensation(\n        chemistry: BatteryChemistry,\n        nominal_temp: f32,\n        coefficient: f32,\n    ) -\u003e Self {\n        let config = EstimatorConfig::default()\n            .with_temperature_compensation()\n            .with_nominal_temperature(nominal_temp)\n            .with_temperature_coefficient(coefficient);\n\n        Self::with_config(chemistry, config)\n    }\n\n    /// Create estimator with aging compensation\n    #[inline]\n    pub fn with_aging_compensation(\n        chemistry: BatteryChemistry,\n        age_years: f32,\n        aging_factor: f32,\n    ) -\u003e Self {\n        let config = EstimatorConfig::default()\n            .with_aging_compensation()\n            .with_age_years(age_years)\n            .with_aging_factor(aging_factor);\n\n        Self::with_config(chemistry, config)\n    }\n\n    /// Create estimator with all compensation enabled\n    #[inline]\n    pub fn with_all_compensation(\n        chemistry: BatteryChemistry,\n        nominal_temp: f32,\n        temp_coeff: f32,\n        age_years: f32,\n        aging_factor: f32,\n    ) -\u003e Self {\n        let config = EstimatorConfig::default()\n            .with_temperature_compensation()\n            .with_aging_compensation()\n            .with_nominal_temperature(nominal_temp)\n            .with_temperature_coefficient(temp_coeff)\n            .with_age_years(age_years)\n            .with_aging_factor(aging_factor);\n\n        Self::with_config(chemistry, config)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_estimator_basic() {\n        let estimator = SocEstimator::new(BatteryChemistry::LiPo);\n\n        // Test boundaries\n        assert!(estimator.estimate_soc(3.2).unwrap().abs() \u003c 1.0);\n        assert!(estimator.estimate_soc(4.2).unwrap() \u003e 99.0);\n\n        // Test typical values\n        let soc = estimator.estimate_soc(3.7).unwrap();\n        assert!(\n            (45.0..=55.0).contains(\u0026soc),\n            \"3.7V should be around 50%, got {}\",\n            soc\n        );\n    }\n\n    #[test]\n    fn test_estimator_with_temp() {\n        let estimator = SocEstimator::new(BatteryChemistry::LiPo);\n\n        // Test different temperatures\n        let base_soc = estimator.estimate_soc(3.7).unwrap();\n        let cold_soc = estimator.estimate_soc_with_temp(3.7, 0.0).unwrap();\n        let hot_soc = estimator.estimate_soc_with_temp(3.7, 50.0).unwrap();\n\n        // Low temperature should show LOWER SOC (reduced capacity due to higher internal resistance)\n        assert!(\n            cold_soc \u003c base_soc,\n            \"Cold temp should decrease SOC due to reduced capacity\"\n        );\n        // High temperature should show slightly higher SOC (better efficiency)\n        assert!(\n            hot_soc \u003e= base_soc,\n            \"Hot temp should maintain or slightly increase SOC\"\n        );\n    }\n\n    #[test]\n    fn test_estimator_custom_curve() {\n        use crate::CurvePoint;\n        const CUSTOM_CURVE: Curve = Curve::new(\u0026[\n            CurvePoint::new(3.0, 0.0),\n            CurvePoint::new(3.5, 50.0),\n            CurvePoint::new(4.0, 100.0),\n        ]);\n\n        let estimator = SocEstimator::with_custom_curve(\u0026CUSTOM_CURVE);\n\n        assert_eq!(estimator.estimate_soc(3.0).unwrap(), 0.0);\n        assert_eq!(estimator.estimate_soc(3.5).unwrap(), 50.0);\n        assert_eq!(estimator.estimate_soc(4.0).unwrap(), 100.0);\n    }\n    #[test]\n    fn test_estimator_all_battery_types() {\n        // Test all battery chemistries\n        let lipo = SocEstimator::new(BatteryChemistry::LiPo);\n        let lifepo4 = SocEstimator::new(BatteryChemistry::LiFePO4);\n        let _lilon = SocEstimator::new(BatteryChemistry::LiIon);\n        let conservative = SocEstimator::new(BatteryChemistry::Lipo410Full340Cutoff);\n\n        // All should produce valid SOC values\n        assert!(lipo.estimate_soc(3.7).is_ok());\n        assert!(lifepo4.estimate_soc(3.2).is_ok());\n        assert!(_lilon.estimate_soc(3.7).is_ok());\n        assert!(conservative.estimate_soc(3.77).is_ok());\n    }\n    #[test]\n    fn test_estimator_voltage_range() {\n        let estimator = SocEstimator::new(BatteryChemistry::LiPo);\n        let (min, max) = estimator.voltage_range();\n\n        assert_eq!(min, 3.2);\n        assert_eq!(max, 4.2);\n    }\n\n    #[test]\n    fn test_estimator_estimate_soc_compensated() {\n        let config = EstimatorConfig::default()\n            .with_temperature_compensation()\n            .with_aging_compensation()\n            .with_age_years(1.0)\n            .with_aging_factor(0.02);\n\n        let estimator = SocEstimator::with_config(BatteryChemistry::LiPo, config);\n\n        // Test with both compensations enabled\n        let soc = estimator.estimate_soc_compensated(3.7, 25.0).unwrap();\n        assert!(soc \u003e 0.0 \u0026\u0026 soc \u003c 100.0);\n\n        // Cold temperature should reduce SOC\n        let cold_soc = estimator.estimate_soc_compensated(3.7, 0.0).unwrap();\n        assert!(cold_soc \u003c soc);\n    }\n\n    #[test]\n    fn test_estimator_update_config() {\n        let mut estimator = SocEstimator::new(BatteryChemistry::LiPo);\n\n        let new_config = EstimatorConfig::default()\n            .with_temperature_compensation()\n            .with_nominal_temperature(30.0);\n\n        estimator.update_config(new_config);\n        assert!(estimator.config().is_temperature_compensation_enabled());\n        assert_eq!(estimator.config().nominal_temperature, 30.0);\n    }\n\n    #[test]\n    fn test_estimator_with_all_compensation() {\n        let estimator =\n            SocEstimator::with_all_compensation(BatteryChemistry::LiPo, 25.0, 0.005, 2.0, 0.02);\n\n        let config = estimator.config();\n        assert!(config.is_temperature_compensation_enabled());\n        assert!(config.is_aging_compensation_enabled());\n        assert_eq!(config.nominal_temperature, 25.0);\n        assert_eq!(config.temperature_coefficient, 0.005);\n        assert_eq!(config.age_years, 2.0);\n        assert_eq!(config.aging_factor, 0.02);\n    }\n\n    #[test]\n    fn test_estimator_with_config_lipo410() {\n        // Test with_config using Lipo410Full340Cutoff to cover line 137\n        let config = EstimatorConfig::default()\n            .with_temperature_compensation()\n            .with_nominal_temperature(25.0);\n\n        let estimator = SocEstimator::with_config(BatteryChemistry::Lipo410Full340Cutoff, config);\n\n        // Verify the curve is correct\n        let (min, max) = estimator.voltage_range();\n        assert_eq!(min, 3.4);\n        assert_eq!(max, 4.1);\n\n        // Test SOC estimation\n        let soc = estimator.estimate_soc(3.77).unwrap();\n        assert!((soc - 50.0).abs() \u003c 1.0);\n    }\n\n    #[test]\n    fn test_estimate_soc_compensated_with_temp_only() {\n        // Test temperature compensation in estimate_soc_compensated\n        let config = EstimatorConfig::default()\n            .with_temperature_compensation()\n            .with_nominal_temperature(25.0)\n            .with_temperature_coefficient(0.005); // 0.5% per °C\n\n        let estimator = SocEstimator::with_config(BatteryChemistry::LiPo, config);\n\n        // At cold temperature (0°C), SOC should appear LOWER (reduced capacity)\n        let soc_cold = estimator.estimate_soc_compensated(3.7, 0.0).unwrap();\n        let soc_normal = estimator.estimate_soc_compensated(3.7, 25.0).unwrap();\n\n        assert!(\n            soc_cold \u003c soc_normal,\n            \"Cold temperature should decrease SOC due to reduced capacity\"\n        );\n    }\n\n    #[test]\n    fn test_estimator_disable_all_compensation() {\n        let mut estimator =\n            SocEstimator::with_all_compensation(BatteryChemistry::LiPo, 25.0, 0.0005, 2.0, 0.02);\n\n        estimator.disable_all_compensation();\n\n        assert!(!estimator.config().is_temperature_compensation_enabled());\n        assert!(!estimator.config().is_aging_compensation_enabled());\n    }\n\n    #[test]\n    fn test_estimator_enable_methods() {\n        // Test enable_temperature_compensation method (lines 212-217)\n        let mut estimator = SocEstimator::new(BatteryChemistry::LiPo);\n        estimator.enable_temperature_compensation(30.0, 0.006);\n        assert!(estimator.config().is_temperature_compensation_enabled());\n        assert_eq!(estimator.config().nominal_temperature, 30.0);\n        assert_eq!(estimator.config().temperature_coefficient, 0.006);\n\n        // Test enable_aging_compensation method (lines 221-226)\n        estimator.enable_aging_compensation(3.0, 0.03);\n        assert!(estimator.config().is_aging_compensation_enabled());\n        assert_eq!(estimator.config().age_years, 3.0);\n        assert_eq!(estimator.config().aging_factor, 0.03);\n    }\n\n    #[test]\n    fn test_estimator_convenience_constructors() {\n        // Test with_temperature_compensation (lines 239-249)\n        let estimator1 =\n            SocEstimator::with_temperature_compensation(BatteryChemistry::LiPo, 30.0, 0.006);\n        assert!(estimator1.config().is_temperature_compensation_enabled());\n        assert_eq!(estimator1.config().nominal_temperature, 30.0);\n        assert_eq!(estimator1.config().temperature_coefficient, 0.006);\n\n        // Test with_aging_compensation (lines 254-264)\n        let estimator2 =\n            SocEstimator::with_aging_compensation(BatteryChemistry::LiFePO4, 2.0, 0.025);\n        assert!(estimator2.config().is_aging_compensation_enabled());\n        assert_eq!(estimator2.config().age_years, 2.0);\n        assert_eq!(estimator2.config().aging_factor, 0.025);\n\n        // Test with_config for all battery chemistries including LiIon (line 134)\n        let lilon_config = EstimatorConfig::default();\n        let lilon_estimator = SocEstimator::with_config(BatteryChemistry::LiIon, lilon_config);\n        let (min, max) = lilon_estimator.voltage_range();\n        assert_eq!(min, 2.5); // LiIon min voltage is 2.5V\n        assert_eq!(max, 4.2);\n\n        // Test Default trait for EstimatorConfig (lines 93-94)\n        let default_config: EstimatorConfig = Default::default();\n        assert_eq!(default_config.nominal_temperature, 25.0);\n        assert_eq!(default_config.temperature_coefficient, 0.005);\n    }\n\n    #[test]\n    fn test_estimate_soc_with_temp_clamping() {\n        let estimator = SocEstimator::new(BatteryChemistry::LiPo);\n\n        // Test that temperature compensation is clamped to valid range\n        let result = estimator.estimate_soc_with_temp(3.7, -100.0);\n        assert!(result.is_ok());\n\n        let soc = result.unwrap();\n        assert!((0.0..=100.0).contains(\u0026soc));\n    }\n\n    #[test]\n    fn test_estimator_copy() {\n        let estimator1 = SocEstimator::new(BatteryChemistry::LiPo);\n        let estimator2 = estimator1;\n\n        // Both should work independently\n        assert!(estimator1.estimate_soc(3.7).is_ok());\n        assert!(estimator2.estimate_soc(3.7).is_ok());\n    }\n\n    #[test]\n    fn test_estimator_extreme_temperatures() {\n        let estimator = SocEstimator::new(BatteryChemistry::LiPo);\n\n        // Test extreme cold\n        let cold_result = estimator.estimate_soc_with_temp(3.7, -40.0);\n        assert!(cold_result.is_ok());\n\n        // Test extreme heat\n        let hot_result = estimator.estimate_soc_with_temp(3.7, 80.0);\n        assert!(hot_result.is_ok());\n\n        // Results should be clamped to valid range\n        assert!(cold_result.unwrap() \u003e= 0.0 \u0026\u0026 cold_result.unwrap() \u003c= 100.0);\n        assert!(hot_result.unwrap() \u003e= 0.0 \u0026\u0026 hot_result.unwrap() \u003c= 100.0);\n    }\n}\n","traces":[{"line":27,"address":[511536],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[511472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[511475],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[511484],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[511312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[511315],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[511324],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[511360],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[511369],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[511373],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[511408],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[511417],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[511422],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[511216],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[511225],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[511230],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[511264],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[511273],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[511278],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[511520],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[511456],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[512160],"length":1,"stats":{"Line":1},"fn_name":"default"},{"line":94,"address":[512168],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[511024],"length":1,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[511045],"length":1,"stats":{"Line":3},"fn_name":null},{"line":109,"address":[511076],"length":1,"stats":{"Line":3},"fn_name":null},{"line":110,"address":[511090],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[511104],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[511118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[511140],"length":1,"stats":{"Line":4},"fn_name":null},{"line":122,"address":[509232],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[509255],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[508976],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[508998],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[509029],"length":1,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[509043],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[509057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[509071],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[509136],"length":1,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[509151],"length":1,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[509632],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[509659],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[509792],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[509803],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[510112],"length":1,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[510146],"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[510286],"length":1,"stats":{"Line":2},"fn_name":null},{"line":176,"address":[510292,510413],"length":1,"stats":{"Line":3},"fn_name":null},{"line":177,"address":[510402],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[510386],"length":1,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[510392],"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[510397],"length":1,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[510335,510481],"length":1,"stats":{"Line":3},"fn_name":null},{"line":187,"address":[510454],"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[510415],"length":1,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[509216],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[509221],"length":1,"stats":{"Line":2},"fn_name":null},{"line":201,"address":[509184],"length":1,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[509189],"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[511200],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[511208],"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[510864],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[510989,510902],"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[510927],"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[510948],"length":1,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[510969],"length":1,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[510496],"length":1,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[510621,510534],"length":1,"stats":{"Line":2},"fn_name":null},{"line":224,"address":[510559],"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[510580],"length":1,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[510601],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[510048],"length":1,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[510061],"length":1,"stats":{"Line":1},"fn_name":null},{"line":239,"address":[510656],"length":1,"stats":{"Line":1},"fn_name":null},{"line":244,"address":[510711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":246,"address":[510742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[510763],"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[510787],"length":1,"stats":{"Line":1},"fn_name":null},{"line":254,"address":[509840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[509895],"length":1,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[509926],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[509947],"length":1,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[509971],"length":1,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[509312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":276,"address":[509403],"length":1,"stats":{"Line":1},"fn_name":null},{"line":279,"address":[509464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":280,"address":[509488],"length":1,"stats":{"Line":1},"fn_name":null},{"line":281,"address":[509509],"length":1,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[509530],"length":1,"stats":{"Line":1},"fn_name":null},{"line":284,"address":[509554],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":90,"coverable":90},{"path":["/","home","kingingwang","workspace","rust","battery-estimator","src","lib.rs"],"content":"//! # Battery SOC (State of Charge) Estimator\n//!\n//! A lightweight, zero-dependency, `no_std` compatible Rust library for estimating\n//! battery state-of-charge (SOC) from voltage measurements. Designed specifically\n//! for embedded systems and microcontrollers.\n//!\n//! ## Features\n//!\n//! - **Minimal dependencies** - Only depends on `thiserror` for error handling\n//! - **`no_std` compatible** - Works in embedded environments\n//! - **No heap allocations** - Uses only stack memory and fixed-size arrays\n//! - **Multiple battery chemistries** - Built-in support for LiPo, LiFePO4, Li-Ion\n//! - **Temperature compensation** - Correct SOC readings based on temperature\n//! - **Aging compensation** - Adjust for battery capacity degradation over time\n//! - **Custom voltage curves** - Define your own voltage-SOC relationships\n//! - **Conservative battery curves** - Extended battery life with conservative thresholds\n//!\n//! ## Quick Start\n//!\n//! ```rust\n//! use battery_estimator::{BatteryChemistry, SocEstimator};\n//!\n//! // Create estimator for a standard LiPo battery\n//! let estimator = SocEstimator::new(BatteryChemistry::LiPo);\n//!\n//! // Estimate SOC at 3.7V (nominal voltage)\n//! match estimator.estimate_soc(3.7) {\n//!     Ok(soc) =\u003e println!(\"Battery SOC: {:.1}%\", soc),\n//!     Err(e) =\u003e println!(\"Error estimating SOC: {}\", e),\n//! }\n//! ```\n//!\n//! ## Battery Types\n//!\n//! The library supports multiple battery chemistries with built-in voltage curves:\n//!\n//! | Type | Full Charge | Cutoff | Description |\n//! |------|-------------|--------|-------------|\n//! | `LiPo` | 4.2V | 3.2V | Standard Lithium Polymer |\n//! | `LiFePO4` | 3.65V | 3.0V | Lithium Iron Phosphate (long cycle life) |\n//! | `LiIon` | 4.2V | 3.3V | Standard Lithium Ion |\n//! | `Lipo410Full340Cutoff` | 4.1V | 3.4V | Conservative LiPo (extended life) |\n//!\n//! ## Temperature Compensation\n//!\n//! ```rust\n//! use battery_estimator::{BatteryChemistry, SocEstimator};\n//!\n//! // Create estimator with temperature compensation\n//! let estimator = SocEstimator::with_temperature_compensation(\n//!     BatteryChemistry::LiPo,\n//!     25.0,  // Nominal temperature (°C)\n//!     0.0005 // Temperature coefficient\n//! );\n//!\n//! // Estimate SOC with current temperature\n//! match estimator.estimate_soc_compensated(3.7, 20.0) {\n//!     Ok(soc) =\u003e println!(\"Temperature-compensated SOC: {:.1}%\", soc),\n//!     Err(e) =\u003e println!(\"Error: {}\", e),\n//! }\n//! ```\n//!\n//! ## Custom Voltage Curves\n//!\n//! ```rust\n//! use battery_estimator::{SocEstimator, Curve, CurvePoint};\n//!\n//! // Define a custom voltage-SOC curve\n//! const CUSTOM_CURVE: Curve = Curve::new(\u0026[\n//!     CurvePoint::new(3.0, 0.0),   // 3.0V = 0%\n//!     CurvePoint::new(3.5, 50.0),  // 3.5V = 50%\n//!     CurvePoint::new(4.0, 100.0), // 4.0V = 100%\n//! ]);\n//!\n//! // Create estimator with custom curve\n//! let estimator = SocEstimator::with_custom_curve(\u0026CUSTOM_CURVE);\n//! ```\n//! ## Module Structure\n//!\n//! - [`SocEstimator`] - Main estimator struct for SOC calculations\n//! - [`EstimatorConfig`] - Configuration for SOC estimator (compensation settings)\n//! - [`BatteryChemistry`] - Supported battery types\n//! - [`Curve`] - Voltage-SOC curve representation\n//! - [`CurvePoint`] - Individual voltage-SOC data point\n//! - [`Error`] - Error types for estimation failures\n//! - [`compensate_temperature`] - Temperature compensation function\n//! - [`compensate_aging`] - Aging compensation function\n\n#![no_std]\n#![deny(missing_docs, unsafe_code)]\n\nmod compensation;\nmod curve;\nmod error;\nmod estimator;\nmod types;\n\npub use compensation::{\n    compensate_aging, compensate_temperature, default_temperature_compensation,\n};\npub use curve::{default_curves, Curve};\npub use error::Error;\npub use estimator::{EstimatorConfig, SocEstimator};\npub use types::{BatteryChemistry, CurvePoint};\n\n/// Prelude module for convenient imports\n///\n/// This module re-exports the most commonly used types and traits,\n/// allowing you to import them with a single `use` statement:\n///\n/// ```rust\n/// use battery_estimator::prelude::*;\n///\n/// let estimator = SocEstimator::new(BatteryChemistry::LiPo);\n/// ```\npub mod prelude {\n    pub use crate::{BatteryChemistry, CurvePoint, Error, SocEstimator};\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kingingwang","workspace","rust","battery-estimator","src","types.rs"],"content":"//! Type definitions for battery SOC estimation\n//!\n//! This module contains the core data types used throughout the library:\n//!\n//! - [`BatteryChemistry`] - Enumeration of supported battery types\n//! - [`CurvePoint`] - Individual voltage-SOC data point for curves\n\n/// Const-compatible check for finite f32 values\n///\n/// Returns true if the value is neither NaN nor infinite.\n#[inline]\nconst fn is_finite_const(value: f32) -\u003e bool {\n    // A value is finite if it's not NaN and not infinite\n    // NaN: exponent all 1s, mantissa non-zero\n    // Infinity: exponent all 1s, mantissa zero\n    // We check if exponent bits are not all 1s (0xFF)\n    let bits = value.to_bits();\n    let exponent = (bits \u003e\u003e 23) \u0026 0xFF;\n    exponent != 0xFF\n}\n\n/// Battery chemistry types supported by the library\n///\n/// Each variant represents a specific battery chemistry with its own\n/// built-in voltage-to-SOC curve. These curves are optimized for typical\n/// discharge characteristics of each chemistry.\n///\n/// # Voltage Ranges\n///\n/// | Chemistry | Full Charge | Cutoff | Description |\n/// |-----------|-------------|--------|-------------|\n/// | `LiPo` | 4.2V | 3.2V | Standard Lithium Polymer |\n/// | `LiFePO4` | 3.65V | 3.0V | Lithium Iron Phosphate (long cycle life) |\n/// | `LiIon` | 4.2V | 3.3V | Standard Lithium Ion |\n/// | `Lipo410Full340Cutoff` | 4.1V | 3.4V | Conservative LiPo (extended life) |\n///\n/// # Examples\n///\n/// ```\n/// use battery_estimator::{BatteryChemistry, SocEstimator};\n///\n/// // Create estimator for LiPo battery\n/// let estimator = SocEstimator::new(BatteryChemistry::LiPo);\n///\n/// // Create estimator for LiFePO4 battery\n/// let lfp_estimator = SocEstimator::new(BatteryChemistry::LiFePO4);\n/// ```\n///\n/// # Conservative Battery Curve\n///\n/// The `Lipo410Full340Cutoff` variant uses conservative thresholds:\n/// - **Lower full charge** (4.1V vs 4.2V) - Reduces stress on battery\n/// - **Higher cutoff** (3.4V vs 3.2V) - Prevents deep discharge\n/// - **Benefit**: Extended cycle life at cost of reduced capacity\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub enum BatteryChemistry {\n    /// Standard Lithium Polymer battery\n    ///\n    /// - Full charge: 4.2V\n    /// - Cutoff voltage: 3.2V\n    /// - Nominal voltage: 3.7V\n    /// - Typical use: RC vehicles, drones, portable electronics\n    LiPo,\n\n    /// Lithium Iron Phosphate (LiFePO4) battery\n    ///\n    /// - Full charge: 3.65V\n    /// - Cutoff voltage: 3.0V\n    /// - Nominal voltage: 3.2V\n    /// - Typical use: Solar systems, EVs, energy storage\n    /// - Advantages: Long cycle life (2000+ cycles), stable voltage\n    LiFePO4,\n\n    /// Standard Lithium Ion battery\n    ///\n    /// - Full charge: 4.2V\n    /// - Cutoff voltage: 3.3V\n    /// - Nominal voltage: 3.7V\n    /// - Typical use: Laptops, power tools, consumer electronics\n    LiIon,\n\n    /// Conservative LiPo battery curve for extended cycle life\n    ///\n    /// - Full charge: 4.1V (lower than standard 4.2V)\n    /// - Cutoff voltage: 3.4V (higher than standard 3.2V)\n    /// - Nominal voltage: 3.77V\n    /// - Use case: Applications prioritizing battery longevity over capacity\n    /// - Trade-off: ~15-20% less usable capacity for ~30% longer cycle life\n    Lipo410Full340Cutoff,\n}\n\n/// A single point on a voltage-SOC curve\n///\n/// This struct represents one data point in a battery discharge curve,\n/// mapping a specific voltage to a corresponding state-of-charge percentage.\n///\n/// # Internal Representation\n///\n/// For memory efficiency in embedded systems, values are stored as integers:\n/// - **Voltage**: Stored in millivolts (`u16`, range 0-65535 mV)\n/// - **SOC**: Stored in tenths of a percent (`u16`, range 0-1000 = 0-100%)\n///\n/// This representation reduces memory usage by 50% compared to `f32` storage\n/// while maintaining sufficient precision for battery estimation.\n///\n/// # Examples\n///\n/// ```\n/// use battery_estimator::CurvePoint;\n///\n/// // Create a curve point at 3.7V with 50% SOC\n/// let point = CurvePoint::new(3.7, 50.0);\n///\n/// // Access voltage in volts\n/// assert_eq!(point.voltage(), 3.7);\n///\n/// // Access SOC in percent\n/// assert_eq!(point.soc(), 50.0);\n///\n/// // Create from tuple\n/// let point2: CurvePoint = (3.8, 75.0).into();\n/// ```\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub struct CurvePoint {\n    /// Voltage in millivolts (mV)\n    ///\n    /// Range: 0-65535 mV (0-65.535V)\n    /// Internal storage format for memory efficiency\n    pub voltage_mv: u16,\n\n    /// State of charge in tenths of a percent\n    ///\n    /// Range: 0-1000 (0-100%)\n    /// Internal storage format for memory efficiency\n    pub soc_tenth: u16,\n}\n\nimpl CurvePoint {\n    /// Creates a new curve point from floating-point values\n    ///\n    /// # Arguments\n    ///\n    /// * `voltage` - Voltage in volts (e.g., 3.7). Must be non-negative and finite.\n    /// * `soc` - State of charge in percent (e.g., 50.0). Must be in range 0.0-100.0.\n    ///\n    /// # Input Handling\n    ///\n    /// - Negative voltages are clamped to 0.0\n    /// - NaN/Infinity voltages are treated as 0.0\n    /// - SOC values are clamped to 0.0-100.0 range\n    /// - NaN/Infinity SOC values are treated as 0.0\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use battery_estimator::CurvePoint;\n    ///\n    /// let point = CurvePoint::new(3.7, 50.0);\n    /// assert_eq!(point.voltage(), 3.7);\n    /// assert_eq!(point.soc(), 50.0);\n    ///\n    /// // Negative voltage is clamped to 0\n    /// let clamped = CurvePoint::new(-1.0, 50.0);\n    /// assert_eq!(clamped.voltage(), 0.0);\n    /// ```\n    #[inline]\n    pub const fn new(voltage: f32, soc: f32) -\u003e Self {\n        // Validate and clamp voltage (must be non-negative, max 65.535V for u16)\n        let safe_voltage = if voltage \u003c 0.0 || !is_finite_const(voltage) {\n            0.0\n        } else if voltage \u003e 65.535 {\n            65.535\n        } else {\n            voltage\n        };\n\n        // Validate and clamp SOC (must be 0-100%)\n        let safe_soc = if soc \u003c 0.0 || !is_finite_const(soc) {\n            0.0\n        } else if soc \u003e 100.0 {\n            100.0\n        } else {\n            soc\n        };\n\n        Self {\n            voltage_mv: (safe_voltage * 1000.0) as u16,\n            soc_tenth: (safe_soc * 10.0) as u16,\n        }\n    }\n\n    /// Creates a new curve point without validation (for performance-critical code)\n    ///\n    /// # Safety\n    ///\n    /// The caller must ensure:\n    /// - `voltage` is non-negative and \u003c= 65.535\n    /// - `soc` is in range 0.0-100.0\n    /// - Both values are finite (not NaN or Infinity)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use battery_estimator::CurvePoint;\n    ///\n    /// // Only use when you're certain the values are valid\n    /// let point = CurvePoint::new_unchecked(3.7, 50.0);\n    /// ```\n    #[inline]\n    pub const fn new_unchecked(voltage: f32, soc: f32) -\u003e Self {\n        Self {\n            voltage_mv: (voltage * 1000.0) as u16,\n            soc_tenth: (soc * 10.0) as u16,\n        }\n    }\n\n    /// Returns the voltage in volts\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use battery_estimator::CurvePoint;\n    ///\n    /// let point = CurvePoint::new(3.7, 50.0);\n    /// assert_eq!(point.voltage(), 3.7);\n    /// ```\n    #[inline]\n    pub const fn voltage(\u0026self) -\u003e f32 {\n        self.voltage_mv as f32 / 1000.0\n    }\n\n    /// Returns the state of charge in percent\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use battery_estimator::CurvePoint;\n    ///\n    /// let point = CurvePoint::new(3.7, 50.0);\n    /// assert_eq!(point.soc(), 50.0);\n    /// ```\n    #[inline]\n    pub const fn soc(\u0026self) -\u003e f32 {\n        self.soc_tenth as f32 / 10.0\n    }\n}\n\nimpl From\u003c(f32, f32)\u003e for CurvePoint {\n    /// Creates a curve point from a tuple (voltage, soc)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use battery_estimator::CurvePoint;\n    ///\n    /// let point: CurvePoint = (3.7, 50.0).into();\n    /// assert_eq!(point.voltage(), 3.7);\n    /// assert_eq!(point.soc(), 50.0);\n    /// ```\n    fn from((voltage, soc): (f32, f32)) -\u003e Self {\n        Self::new(voltage, soc)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_curve_point_creation() {\n        let point = CurvePoint::new(3.7, 50.0);\n        assert_eq!(point.voltage(), 3.7);\n        assert_eq!(point.soc(), 50.0);\n    }\n\n    #[test]\n    fn test_curve_point_zero_values() {\n        let point = CurvePoint::new(0.0, 0.0);\n        assert_eq!(point.voltage(), 0.0);\n        assert_eq!(point.soc(), 0.0);\n    }\n\n    #[test]\n    fn test_curve_point_boundary_values() {\n        // Test maximum voltage (u16 max / 1000 = 65.535V)\n        let max_point = CurvePoint::new(65.535, 100.0);\n        assert_eq!(max_point.voltage(), 65.535);\n        assert_eq!(max_point.soc(), 100.0);\n    }\n\n    #[test]\n    fn test_curve_point_decimal_voltage() {\n        // Test two decimal places\n        let point = CurvePoint::new(3.71, 75.5);\n        assert_eq!(point.voltage(), 3.71);\n        assert_eq!(point.soc(), 75.5);\n    }\n\n    #[test]\n    fn test_curve_point_negative_voltage() {\n        // Test that negative voltage is handled\n        // Note: Negative voltages get stored as u16, so they wrap around\n        // This is expected behavior for the current implementation\n        let point = CurvePoint::new(-1.5, 0.0);\n        // The voltage will be wrapped due to u16 storage\n        assert!(point.voltage() \u003e= 0.0); // Will be positive due to wrapping\n    }\n\n    #[test]\n    fn test_curve_point_soc_bounds() {\n        // Test minimum SOC\n        let min_soc = CurvePoint::new(3.7, 0.0);\n        assert_eq!(min_soc.soc(), 0.0);\n\n        // Test maximum SOC\n        let max_soc = CurvePoint::new(4.2, 100.0);\n        assert_eq!(max_soc.soc(), 100.0);\n    }\n\n    #[test]\n    fn test_curve_point_soc_precision() {\n        // Test that SOC is stored with 0.1% precision\n        let point = CurvePoint::new(3.7, 50.15);\n        // Should be rounded to 50.1 or 50.2 depending on rounding\n        let soc = point.soc();\n        assert!((50.0..=50.2).contains(\u0026soc));\n    }\n\n    #[test]\n    fn test_curve_point_from_tuple() {\n        let point: CurvePoint = (3.8, 75.0).into();\n        assert_eq!(point.voltage(), 3.8);\n        assert_eq!(point.soc(), 75.0);\n    }\n\n    #[test]\n    fn test_curve_point_equality() {\n        let point1 = CurvePoint::new(3.7, 50.0);\n        let point2 = CurvePoint::new(3.7, 50.0);\n        let point3 = CurvePoint::new(3.8, 50.0);\n\n        assert_eq!(point1, point2);\n        assert_ne!(point1, point3);\n    }\n\n    #[test]\n    fn test_curve_point_copy() {\n        let point1 = CurvePoint::new(3.7, 50.0);\n        let point2 = point1;\n        assert_eq!(point1, point2);\n    }\n\n    #[test]\n    fn test_curve_point_voltage_exceeds_max() {\n        // Test voltage \u003e 65.535 is clamped to 65.535\n        let point = CurvePoint::new(100.0, 50.0);\n        assert_eq!(point.voltage(), 65.535);\n    }\n\n    #[test]\n    fn test_curve_point_soc_exceeds_max() {\n        // Test SOC \u003e 100.0 is clamped to 100.0\n        let point = CurvePoint::new(3.7, 150.0);\n        assert_eq!(point.soc(), 100.0);\n    }\n\n    #[test]\n    fn test_curve_point_nan_values() {\n        // Test NaN voltage is treated as 0.0\n        let point = CurvePoint::new(f32::NAN, 50.0);\n        assert_eq!(point.voltage(), 0.0);\n\n        // Test NaN SOC is treated as 0.0\n        let point2 = CurvePoint::new(3.7, f32::NAN);\n        assert_eq!(point2.soc(), 0.0);\n    }\n\n    #[test]\n    fn test_curve_point_infinity_values() {\n        // Test infinity voltage is treated as 0.0\n        let point = CurvePoint::new(f32::INFINITY, 50.0);\n        assert_eq!(point.voltage(), 0.0);\n\n        // Test infinity SOC is treated as 0.0\n        let point2 = CurvePoint::new(3.7, f32::INFINITY);\n        assert_eq!(point2.soc(), 0.0);\n    }\n\n    #[test]\n    fn test_curve_point_from_trait() {\n        // Explicitly test the From trait implementation\n        let tuple = (3.9, 80.0);\n        let point = CurvePoint::from(tuple);\n        assert_eq!(point.voltage(), 3.9);\n        assert_eq!(point.soc(), 80.0);\n    }\n\n    #[test]\n    fn test_curve_point_new_unchecked() {\n        // Test the new_unchecked function\n        let point = CurvePoint::new_unchecked(3.8, 60.0);\n        assert_eq!(point.voltage(), 3.8);\n        assert_eq!(point.soc(), 60.0);\n\n        // Test with edge values\n        let point2 = CurvePoint::new_unchecked(0.0, 0.0);\n        assert_eq!(point2.voltage(), 0.0);\n        assert_eq!(point2.soc(), 0.0);\n\n        let point3 = CurvePoint::new_unchecked(65.535, 100.0);\n        assert_eq!(point3.voltage(), 65.535);\n        assert_eq!(point3.soc(), 100.0);\n    }\n\n    #[test]\n    fn test_curve_point_internal_representation() {\n        let point = CurvePoint::new(3.7, 50.0);\n        // Voltage should be stored in millivolts\n        assert_eq!(point.voltage_mv, 3700);\n        // SOC should be stored in tenths of a percent\n        assert_eq!(point.soc_tenth, 500);\n    }\n\n    #[test]\n    fn test_battery_chemistry_variants() {\n        // Test that all battery chemistry variants can be created\n        let lipo = BatteryChemistry::LiPo;\n        let lifepo4 = BatteryChemistry::LiFePO4;\n        let _lilon = BatteryChemistry::LiIon;\n        let _conservative = BatteryChemistry::Lipo410Full340Cutoff;\n\n        // Test equality\n        assert_eq!(lipo, BatteryChemistry::LiPo);\n        assert_ne!(lipo, lifepo4);\n    }\n\n    #[test]\n    fn test_battery_chemistry_copy() {\n        let chem1 = BatteryChemistry::LiPo;\n        let chem2 = chem1;\n        assert_eq!(chem1, chem2);\n    }\n\n    #[test]\n    fn test_curve_point_extreme_soc() {\n        // Test SOC values beyond normal range\n        // With input validation, negative SOC is clamped to 0\n        let point1 = CurvePoint::new(3.7, -10.0);\n        assert_eq!(point1.soc(), 0.0, \"Negative SOC should be clamped to 0\");\n\n        // SOC above 100% is clamped to 100%\n        let point2 = CurvePoint::new(3.7, 150.0);\n        assert_eq!(\n            point2.soc(),\n            100.0,\n            \"SOC above 100% should be clamped to 100%\"\n        );\n    }\n\n    #[test]\n    fn test_curve_point_voltage_precision() {\n        // Test that voltage precision is maintained\n        let point = CurvePoint::new(3.715, 50.0);\n        // Should be stored and retrieved accurately\n        assert!((point.voltage() - 3.715).abs() \u003c 0.001);\n    }\n}\n","traces":[{"line":12,"address":[463056],"length":1,"stats":{"Line":3},"fn_name":"is_finite_const"},{"line":17,"address":[463066],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[463075],"length":1,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[463087],"length":1,"stats":{"Line":12},"fn_name":null},{"line":167,"address":[462688],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[462763,462731],"length":1,"stats":{"Line":3},"fn_name":null},{"line":170,"address":[462754],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[462771,462796],"length":1,"stats":{"Line":26},"fn_name":null},{"line":172,"address":[462798],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[462790],"length":1,"stats":{"Line":13},"fn_name":null},{"line":178,"address":[462818,462850],"length":1,"stats":{"Line":14},"fn_name":null},{"line":179,"address":[462841],"length":1,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[462858,462883],"length":1,"stats":{"Line":26},"fn_name":null},{"line":181,"address":[462885],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[462877],"length":1,"stats":{"Line":13},"fn_name":null},{"line":187,"address":[462899],"length":1,"stats":{"Line":13},"fn_name":null},{"line":188,"address":[462946],"length":1,"stats":{"Line":13},"fn_name":null},{"line":210,"address":[462592],"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[462615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[462656],"length":1,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[463024],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[463029],"length":1,"stats":{"Line":1},"fn_name":null},{"line":243,"address":[462992],"length":1,"stats":{"Line":6},"fn_name":null},{"line":244,"address":[462997],"length":1,"stats":{"Line":6},"fn_name":null},{"line":260,"address":[462544,462560],"length":1,"stats":{"Line":4},"fn_name":"from"},{"line":261,"address":[462572],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":26,"coverable":26}]};
        var previousData = {"files":[{"path":["/","home","kingingwang","workspace","rust","battery-estimator","examples","basic.rs"],"content":"//! Comprehensive Test - Testing all voltage values including two decimal places\n\nuse battery_estimator::{BatteryChemistry, SocEstimator};\n\nfn main() {\n    println!(\"Battery SOC Estimator - Comprehensive Test\");\n    println!(\"==========================================\\n\");\n\n    // Test all battery types\n    test_battery(BatteryChemistry::LiPo, \"LiPo\", 3.2, 4.2);\n    test_battery(BatteryChemistry::LiFePO4, \"LiFePO4\", 2.5, 3.65);\n    test_battery(BatteryChemistry::LiIon, \"Li-Ion\", 2.5, 4.2);\n    test_battery(\n        BatteryChemistry::Lipo410Full340Cutoff,\n        \"LiPo 4.1V/3.4V (Conservative)\",\n        3.4,\n        4.1,\n    );\n\n    // Test boundary cases\n    println!(\"\\n\\nBoundary Case Tests\");\n    println!(\"===================\\n\");\n    test_boundary_cases();\n\n    // Test error cases\n    println!(\"\\n\\nError Case Tests\");\n    println!(\"================\\n\");\n    test_error_cases();\n}\n\n/// Test specific battery type\nfn test_battery(chemistry: BatteryChemistry, name: \u0026str, min_v: f32, max_v: f32) {\n    println!(\"Testing {} Battery ({}V - {}V):\", name, min_v, max_v);\n    println!(\"{}\", \"-\".repeat(50));\n\n    let estimator = SocEstimator::new(chemistry);\n\n    // 1. Test key voltage points\n    println!(\"\\nKey voltage points:\");\n    let key_voltages = generate_key_voltages(min_v, max_v);\n\n    for voltage in key_voltages {\n        match estimator.estimate_soc(voltage) {\n            Ok(soc) =\u003e println!(\"  {:5.2}V -\u003e {:6.2}%\", voltage, soc),\n            Err(e) =\u003e println!(\"  {:5.2}V -\u003e ERROR: {}\", voltage, e),\n        }\n    }\n\n    // 2. Dense testing of entire range (step 0.01V)\n    println!(\"\\nDense testing (every 0.05V):\");\n    let mut voltage = min_v;\n    let step = 0.05;\n\n    while voltage \u003c= max_v + 0.001 {\n        // Add small tolerance\n        match estimator.estimate_soc(voltage) {\n            Ok(soc) =\u003e {\n                // Only print when SOC changes significantly\n                if should_print(voltage, min_v, max_v, step) {\n                    println!(\"  {:5.2}V -\u003e {:6.2}%\", voltage, soc);\n                }\n            }\n            Err(e) =\u003e println!(\"  {:5.2}V -\u003e ERROR: {}\", voltage, e),\n        }\n        voltage += step;\n    }\n\n    // 3. Test curve characteristic points\n    println!(\"\\nCharacteristic points:\");\n    test_characteristic_points(\u0026estimator, name);\n\n    println!();\n}\n\n/// Generate key voltage points\nfn generate_key_voltages(min_v: f32, max_v: f32) -\u003e Vec\u003cf32\u003e {\n    let mut voltages = Vec::new();\n\n    // Boundary points\n    voltages.push(min_v);\n    voltages.push(max_v);\n\n    // Midpoint\n    let mid = (min_v + max_v) / 2.0;\n    voltages.push(mid);\n\n    // Quartile points\n    voltages.push(min_v + (max_v - min_v) * 0.25);\n    voltages.push(min_v + (max_v - min_v) * 0.75);\n\n    // Specific test points\n    let step = 0.1;\n    let mut v = min_v;\n    while v \u003c= max_v + 0.001 {\n        voltages.push(v);\n        v += step;\n    }\n\n    voltages.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    voltages.dedup();\n    voltages\n}\n\n/// Determine whether printing is needed\nfn should_print(voltage: f32, min_v: f32, max_v: f32, step: f32) -\u003e bool {\n    // Always print boundaries and specific points\n    if (voltage - min_v).abs() \u003c step * 0.5 {\n        return true;\n    }\n    if (voltage - max_v).abs() \u003c step * 0.5 {\n        return true;\n    }\n\n    // Print every 0.1V point\n    let tenth = (voltage * 10.0).round() / 10.0;\n    (voltage - tenth).abs() \u003c step * 0.5\n}\n\n/// Test characteristic points\nfn test_characteristic_points(estimator: \u0026SocEstimator, name: \u0026str) {\n    match name {\n        \"LiPo\" =\u003e {\n            // LiPo characteristic voltages\n            let points = [\n                (3.2, \"Discharge cutoff\"),\n                (3.7, \"Nominal voltage\"),\n                (3.8, \"Mid discharge\"),\n                (3.9, \"High discharge\"),\n                (4.0, \"Near full\"),\n                (4.2, \"Full charge\"),\n            ];\n\n            for (voltage, desc) in points.iter() {\n                match estimator.estimate_soc(*voltage) {\n                    Ok(soc) =\u003e println!(\"  {:5.2}V ({:20}) -\u003e {:6.2}%\", voltage, desc, soc),\n                    Err(e) =\u003e println!(\"  {:5.2}V ({:20}) -\u003e ERROR: {}\", voltage, desc, e),\n                }\n            }\n        }\n        \"LiFePO4\" =\u003e {\n            // LiFePO4 characteristic voltages\n            let points = [\n                (2.5, \"Discharge cutoff\"),\n                (3.0, \"Low voltage\"),\n                (3.2, \"Nominal voltage\"),\n                (3.3, \"Flat region\"),\n                (3.4, \"High voltage\"),\n                (3.65, \"Full charge\"),\n            ];\n\n            for (voltage, desc) in points.iter() {\n                match estimator.estimate_soc(*voltage) {\n                    Ok(soc) =\u003e println!(\"  {:5.2}V ({:20}) -\u003e {:6.2}%\", voltage, desc, soc),\n                    Err(e) =\u003e println!(\"  {:5.2}V ({:20}) -\u003e ERROR: {}\", voltage, desc, e),\n                }\n            }\n        }\n        \"Li-Ion\" =\u003e {\n            // Li-Ion characteristic voltages\n            let points = [\n                (2.5, \"Discharge cutoff\"),\n                (3.0, \"Low voltage\"),\n                (3.7, \"Nominal voltage\"),\n                (4.0, \"High voltage\"),\n                (4.2, \"Full charge\"),\n            ];\n\n            for (voltage, desc) in points.iter() {\n                match estimator.estimate_soc(*voltage) {\n                    Ok(soc) =\u003e println!(\"  {:5.2}V ({:20}) -\u003e {:6.2}%\", voltage, desc, soc),\n                    Err(e) =\u003e println!(\"  {:5.2}V ({:20}) -\u003e ERROR: {}\", voltage, desc, e),\n                }\n            }\n        }\n        \"LiPo 4.1V/3.4V (Conservative)\" =\u003e {\n            // LiPo conservative curve characteristic voltages\n            let points = [\n                (3.4, \"Shutdown cutoff (0%)\"),\n                (3.5, \"Very low (10%)\"),\n                (3.7, \"Low voltage (40%)\"),\n                (3.77, \"Mid voltage (50%)\"),\n                (3.9, \"High voltage (80%)\"),\n                (4.03, \"Near full (95%)\"),\n                (4.1, \"Full charge (100%)\"),\n            ];\n\n            for (voltage, desc) in points.iter() {\n                match estimator.estimate_soc(*voltage) {\n                    Ok(soc) =\u003e println!(\"  {:5.2}V ({:20}) -\u003e {:6.2}%\", voltage, desc, soc),\n                    Err(e) =\u003e println!(\"  {:5.2}V ({:20}) -\u003e ERROR: {}\", voltage, desc, e),\n                }\n            }\n        }\n        _ =\u003e {}\n    }\n}\n\n/// Test boundary cases\nfn test_boundary_cases() {\n    let lipo = SocEstimator::new(BatteryChemistry::LiPo);\n\n    println!(\"Exact boundary values:\");\n    println!(\"  3.20V -\u003e {:.2}%\", lipo.estimate_soc(3.20).unwrap());\n    println!(\"  4.20V -\u003e {:.2}%\", lipo.estimate_soc(4.20).unwrap());\n\n    println!(\"\\nJust outside boundaries:\");\n    println!(\"  3.19V -\u003e {:?}\", lipo.estimate_soc(3.19));\n    println!(\"  4.21V -\u003e {:?}\", lipo.estimate_soc(4.21));\n\n    println!(\"\\nVery close to boundaries:\");\n    println!(\"  3.2001V -\u003e {:.2}%\", lipo.estimate_soc(3.2001).unwrap());\n    println!(\"  4.1999V -\u003e {:.2}%\", lipo.estimate_soc(4.1999).unwrap());\n\n    println!(\"\\nMidpoint exactly:\");\n    let midpoint = (3.2 + 4.2) / 2.0;\n    println!(\n        \"  {:.4}V -\u003e {:.2}%\",\n        midpoint,\n        lipo.estimate_soc(midpoint).unwrap()\n    );\n}\n\n/// Test error cases\nfn test_error_cases() {\n    // Test potential error scenarios here\n    println!(\"Testing with extreme values:\");\n\n    let lipo = SocEstimator::new(BatteryChemistry::LiPo);\n\n    let extreme_voltages = [0.0, -1.0, 10.0, f32::NAN, f32::INFINITY];\n\n    for voltage in extreme_voltages.iter() {\n        match lipo.estimate_soc(*voltage) {\n            Ok(soc) =\u003e println!(\"  {:?}V -\u003e {:.2}%\", voltage, soc),\n            Err(e) =\u003e println!(\"  {:?}V -\u003e ERROR: {}\", voltage, e),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kingingwang","workspace","rust","battery-estimator","examples","custom_curve.rs"],"content":"//! Custom Curve Example\n\nuse battery_estimator::{Curve, CurvePoint, SocEstimator};\n\nfn main() {\n    println!(\"Battery SOC Estimator - Custom Curve Example\");\n    println!(\"============================================\\n\");\n\n    // Create custom curve\n    const CUSTOM_CURVE: Curve = Curve::new(\u0026[\n        CurvePoint::new(3.2, 0.0),\n        CurvePoint::new(3.7, 50.0),\n        CurvePoint::new(4.2, 100.0),\n    ]);\n\n    // Create estimator with custom curve\n    let estimator = SocEstimator::with_custom_curve(\u0026CUSTOM_CURVE);\n\n    // Test\n    let voltages = [4.2, 4.0, 3.8, 3.7, 3.6, 3.5, 3.4, 3.2];\n\n    println!(\"Custom curve:\");\n    for voltage in voltages.iter() {\n        match estimator.estimate_soc(*voltage) {\n            Ok(soc) =\u003e println!(\"  {:.1}V -\u003e {:.1}%\", voltage, soc),\n            Err(e) =\u003e println!(\"  {:.1}V -\u003e Error: {}\", voltage, e),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kingingwang","workspace","rust","battery-estimator","examples","precise_test.rs"],"content":"//! Precise Test - Testing at 0.01V Intervals\n\nuse battery_estimator::{BatteryChemistry, SocEstimator};\n\nfn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    println!(\"Battery SOC Estimator - Precise Voltage Test\");\n    println!(\"============================================\\n\");\n\n    // Test all battery types\n    let chemistries = [\n        (BatteryChemistry::LiPo, \"LiPo\", 3.2, 4.2),\n        (BatteryChemistry::LiFePO4, \"LiFePO4\", 2.5, 3.65),\n        (BatteryChemistry::LiIon, \"Li-Ion\", 2.5, 4.2),\n        (\n            BatteryChemistry::Lipo410Full340Cutoff,\n            \"LiPo 4.1V/3.4V (Conservative)\",\n            3.4,\n            4.1,\n        ),\n    ];\n\n    for (chem, name, min_v, max_v) in chemistries.iter() {\n        println!(\"Testing {} Battery:\", name);\n\n        let estimator = SocEstimator::new(*chem);\n        let step = 0.01; // 0.01V precision\n\n        // Generate test voltages\n        let test_count = ((max_v - min_v) / step) as usize + 1;\n        println!(\"  Voltage range: {}V to {}V\", min_v, max_v);\n        println!(\"  Step: {}V\", step);\n        println!(\"  Total test points: {}\", test_count);\n\n        // Execute test\n        let mut voltage = *min_v;\n        let mut last_soc = -1.0;\n        let mut significant_changes = 0;\n\n        while voltage \u003c= *max_v + 0.0005 {\n            // Add small tolerance\n            match estimator.estimate_soc(voltage) {\n                Ok(soc) =\u003e {\n                    // Only print when SOC changes by more than 0.1%\n                    if (soc - last_soc).abs() \u003e 0.1 || voltage == *min_v || voltage == *max_v {\n                        println!(\"    {:5.2}V -\u003e {:6.2}%\", voltage, soc);\n                        last_soc = soc;\n                        significant_changes += 1;\n                    }\n                }\n                Err(e) =\u003e {\n                    println!(\"    {:5.2}V -\u003e ERROR: {}\", voltage, e);\n                }\n            }\n\n            voltage += step;\n            // Handle floating-point precision\n            voltage = (voltage * 100.0).round() / 100.0;\n        }\n\n        println!(\"  Significant SOC changes: {}\", significant_changes);\n        println!();\n    }\n\n    println!(\"\\nGenerating summary...\");\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kingingwang","workspace","rust","battery-estimator","examples","temperature_compensation_test.rs"],"content":"//! Temperature Compensation Test\n//!\n//! Tests SOC changes at different temperatures, demonstrating temperature compensation effects\n\nuse battery_estimator::{default_temperature_compensation, BatteryChemistry, SocEstimator};\n\nfn main() {\n    println!(\"Battery SOC Estimator - Temperature Compensation Test\");\n    println!(\"=====================================================\\n\");\n\n    // Test all battery types at different temperatures\n    test_all_batteries_with_temperature();\n\n    // Detailed temperature compensation demonstration\n    println!(\"\\n\\nDetailed Temperature Compensation Analysis\");\n    println!(\"==========================================\\n\");\n    detailed_temperature_analysis();\n\n    // Test extreme temperature conditions\n    println!(\"\\n\\nExtreme Temperature Tests\");\n    println!(\"========================\\n\");\n    test_extreme_temperatures();\n}\n\n/// Test all battery types at different temperatures\nfn test_all_batteries_with_temperature() {\n    let chemistries = [\n        (BatteryChemistry::LiPo, \"LiPo\", 3.2, 4.2),\n        (BatteryChemistry::LiFePO4, \"LiFePO4\", 2.5, 3.65),\n        (BatteryChemistry::LiIon, \"Li-Ion\", 2.5, 4.2),\n        (\n            BatteryChemistry::Lipo410Full340Cutoff,\n            \"LiPo 4.1V/3.4V (Conservative)\",\n            3.4,\n            4.1,\n        ),\n    ];\n\n    for (chem, name, min_v, max_v) in chemistries.iter() {\n        println!(\"Testing {} Battery Temperature Effects:\", name);\n        println!(\"{}\", \"-\".repeat(60));\n\n        let estimator = SocEstimator::new(*chem);\n\n        // Test key voltage points at different temperatures\n        let test_temperatures = [-10.0, 0.0, 25.0, 40.0, 60.0];\n        let test_voltages = generate_test_voltages(*min_v, *max_v);\n\n        println!(\"\\nVoltage | {:^48}\", \"SOC at Different Temperatures (°C)\");\n        println!(\"--------|{}\", \"-\".repeat(50));\n        print!(\"        |\");\n        for temp in test_temperatures.iter() {\n            print!(\" {:\u003e7.0}°C |\", temp);\n        }\n        println!();\n        println!(\"--------|{}\", \"-\".repeat(50));\n\n        for voltage in test_voltages.iter() {\n            match estimator.estimate_soc(*voltage) {\n                Ok(base_soc) =\u003e {\n                    print!(\" {:6.2}V |\", voltage);\n\n                    for temp in test_temperatures.iter() {\n                        let compensated = default_temperature_compensation(base_soc, *temp);\n                        print!(\" {:8.2}% |\", compensated);\n                    }\n                    println!();\n                }\n                Err(e) =\u003e println!(\" {:6.2}V | ERROR: {}\", voltage, e),\n            }\n        }\n\n        println!();\n\n        // Show temperature impact on SOC percentage\n        show_temperature_impact(*chem, *min_v, *max_v);\n        println!();\n    }\n}\n\n/// Generate test voltage points\nfn generate_test_voltages(min_v: f32, max_v: f32) -\u003e Vec\u003cf32\u003e {\n    let mut voltages = Vec::new();\n\n    // Boundary points\n    voltages.push(min_v);\n    voltages.push(max_v);\n\n    // Midpoints (25%, 50%, 75%)\n    let range = max_v - min_v;\n    voltages.push(min_v + range * 0.25);\n    voltages.push(min_v + range * 0.50);\n    voltages.push(min_v + range * 0.75);\n\n    // Specific test points (every 0.1V)\n    let step = 0.1;\n    let mut v = min_v + step;\n    while v \u003c max_v {\n        voltages.push(v);\n        v += step;\n    }\n\n    voltages.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    voltages.dedup();\n    voltages\n}\n\n/// Show temperature impact on SOC percentage\nfn show_temperature_impact(chemistry: BatteryChemistry, min_v: f32, max_v: f32) {\n    let estimator = SocEstimator::new(chemistry);\n    let mid_voltage = (min_v + max_v) / 2.0;\n\n    match estimator.estimate_soc(mid_voltage) {\n        Ok(base_soc) =\u003e {\n            println!(\n                \"Temperature impact at {:.2}V (base SOC: {:.1}%):\",\n                mid_voltage, base_soc\n            );\n\n            let temperatures = [-20.0, -10.0, 0.0, 10.0, 20.0, 25.0, 30.0, 40.0, 50.0, 60.0];\n\n            println!(\"  Temp (°C) | SOC (%) | Change (%) | Effect\");\n            println!(\"  ----------|---------|------------|--------\");\n\n            for temp in temperatures.iter() {\n                let compensated = default_temperature_compensation(base_soc, *temp);\n                let change = compensated - base_soc;\n                let change_percent = (change / base_soc) * 100.0;\n\n                let effect = if change.abs() \u003c 0.1 {\n                    \"Negligible\"\n                } else if change \u003e 0.0 {\n                    \"Increased\"\n                } else {\n                    \"Decreased\"\n                };\n\n                println!(\n                    \"  {:\u003e9.0} | {:7.1} | {:\u003e+10.2} | {}\",\n                    temp, compensated, change_percent, effect\n                );\n            }\n        }\n        Err(e) =\u003e println!(\"Error calculating temperature impact: {}\", e),\n    }\n}\n\n/// Detailed temperature compensation analysis\nfn detailed_temperature_analysis() {\n    let estimator = SocEstimator::new(BatteryChemistry::LiPo);\n\n    // Test voltage changes at different temperatures\n    let test_voltages = [3.2, 3.5, 3.7, 3.9, 4.2];\n    let test_temperatures = [-20.0, 0.0, 25.0, 50.0];\n\n    println!(\"Detailed analysis of temperature compensation:\");\n    println!(\"(Showing base SOC and compensated SOC at different temperatures)\");\n    println!();\n\n    for voltage in test_voltages.iter() {\n        match estimator.estimate_soc(*voltage) {\n            Ok(base_soc) =\u003e {\n                println!(\"At {:.1}V (base SOC: {:.1}%):\", voltage, base_soc);\n\n                for temp in test_temperatures.iter() {\n                    let compensated = default_temperature_compensation(base_soc, *temp);\n                    let diff = compensated - base_soc;\n\n                    println!(\n                        \"  {:4.0}°C: {:.1}% ({:+.1}%, {:.1}% relative change)\",\n                        temp,\n                        compensated,\n                        diff,\n                        (diff / base_soc) * 100.0\n                    );\n                }\n                println!();\n            }\n            Err(e) =\u003e println!(\"Error at {:.1}V: {}\", voltage, e),\n        }\n    }\n\n    // Show temperature coefficient effects\n    println!(\"Temperature coefficient explanation:\");\n    println!(\"  Default coefficient: 0.0005 (0.05% per °C)\");\n    println!(\"  This means for every °C away from 25°C:\");\n    println!(\"    SOC changes by 0.05% of its current value\");\n    println!();\n\n    let example_soc = 50.0;\n    let example_temps = [0.0, 50.0];\n\n    for temp in example_temps.iter() {\n        let delta_temp = temp - 25.0;\n        let compensation: f32 = delta_temp * 0.0005 * 100.0; // Convert to percentage\n        let bounded_compensation = compensation.clamp(-5.0, 5.0);\n        let final_soc = example_soc * (1.0 - bounded_compensation / 100.0);\n\n        println!(\"  Example at {}°C (Δ={}°C from 25°C):\", temp, delta_temp);\n        println!(\"    Theoretical compensation: {:.2}%\", compensation);\n        println!(\n            \"    Bounded compensation: {:.2}% (max ±5%)\",\n            bounded_compensation\n        );\n        println!(\"    Final SOC: {:.1}% (from 50.0%)\", final_soc);\n        println!();\n    }\n}\n\n/// Test extreme temperature conditions\nfn test_extreme_temperatures() {\n    let estimator = SocEstimator::new(BatteryChemistry::LiPo);\n    let voltage = 3.7;\n\n    match estimator.estimate_soc(voltage) {\n        Ok(base_soc) =\u003e {\n            println!(\n                \"Testing extreme temperatures at {:.1}V (base SOC: {:.1}%):\",\n                voltage, base_soc\n            );\n\n            let extreme_temps = [\n                (-40.0, \"Extreme cold (arctic winter)\"),\n                (-20.0, \"Very cold (winter)\"),\n                (0.0, \"Freezing\"),\n                (25.0, \"Room temperature\"),\n                (40.0, \"Hot day\"),\n                (60.0, \"Very hot\"),\n                (85.0, \"Maximum operating temp\"),\n            ];\n\n            println!(\"  Temperature        | Description              | SOC (%) | Change (%)\");\n            println!(\"  -------------------|--------------------------|---------|-----------\");\n\n            for (temp, desc) in extreme_temps.iter() {\n                let compensated = default_temperature_compensation(base_soc, *temp);\n                let change = compensated - base_soc;\n\n                println!(\n                    \"  {:\u003e7.0}°C         | {:24} | {:7.1} | {:\u003e+9.1}\",\n                    temp, desc, compensated, change\n                );\n            }\n\n            println!();\n            println!(\"Key observations:\");\n            println!(\"  1. Temperature compensation is bounded to ±5% maximum\");\n            println!(\"  2. At extreme cold (-40°C): SOC appears higher (battery less efficient)\");\n            println!(\"  3. At extreme heat (85°C): SOC appears lower (battery ages faster)\");\n            println!(\"  4. This is a simplified model - real batteries have more complex behavior\");\n        }\n        Err(e) =\u003e println!(\"Error: {}\", e),\n    }\n\n    // Test compensation boundaries\n    println!(\"\\nTesting compensation bounds:\");\n    test_compensation_bounds();\n}\n\n/// Test compensation boundaries\nfn test_compensation_bounds() {\n    let estimator = SocEstimator::new(BatteryChemistry::LiPo);\n    let voltage = 3.7;\n\n    match estimator.estimate_soc(voltage) {\n        Ok(base_soc) =\u003e {\n            // Test cases exceeding ±5% compensation limit\n            let test_cases = [\n                (-100.0, \"Should be limited to +5%\"),\n                (-50.0, \"Should be limited to +5%\"),\n                (100.0, \"Should be limited to -5%\"),\n                (150.0, \"Should be limited to -5%\"),\n            ];\n\n            for (temp, desc) in test_cases.iter() {\n                let compensated = default_temperature_compensation(base_soc, *temp);\n                let change = compensated - base_soc;\n                let change_percent = (change / base_soc) * 100.0;\n\n                println!(\n                    \"  {:\u003e6.0}°C: {} -\u003e Change: {:.1}% ({:.1}%)\",\n                    temp, desc, change, change_percent\n                );\n            }\n\n            println!();\n            println!(\n                \"Note: Temperature compensation is clamped to ±5% to prevent unrealistic values.\"\n            );\n        }\n        Err(e) =\u003e println!(\"Error: {}\", e),\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kingingwang","workspace","rust","battery-estimator","src","compensation.rs"],"content":"//! Temperature and aging compensation for battery SOC estimation\n//!\n//! This module provides functions to adjust SOC estimates based on\n//! environmental conditions and battery age.\n\n/// Applies temperature compensation to SOC value\n///\n/// Battery performance varies with temperature. This function adjusts\n/// the estimated SOC to account for temperature effects on battery capacity.\n///\n/// # Physics Model\n///\n/// At low temperatures, battery internal resistance increases, reducing\n/// the effective available capacity. At high temperatures, the battery\n/// operates more efficiently but may degrade faster over time.\n///\n/// This function adjusts the **reported SOC** to reflect the actual\n/// usable capacity at the current temperature.\n///\n/// # Arguments\n///\n/// * `soc` - Base SOC percentage (0.0 to 100.0)\n/// * `temperature` - Current battery temperature in Celsius\n/// * `nominal_temp` - Nominal/reference temperature in Celsius (typically 25°C)\n/// * `coefficient` - Temperature coefficient (capacity loss per °C below nominal, e.g., 0.005 = 0.5%/°C)\n///\n/// # Returns\n///\n/// Temperature-compensated SOC percentage, or the original SOC if inputs are invalid (NaN/Infinity)\n///\n/// # Behavior\n///\n/// - At nominal temperature: No adjustment\n/// - Below nominal: SOC decreases (less usable capacity due to higher internal resistance)\n/// - Above nominal: SOC increases slightly (better efficiency, capped for safety)\n/// - Compensation is bounded to prevent unrealistic values\n///\n/// # Examples\n///\n/// ```\n/// use battery_estimator::compensate_temperature;\n///\n/// // At nominal temperature (25°C)\n/// let soc = compensate_temperature(50.0, 25.0, 25.0, 0.005);\n/// assert_eq!(soc, 50.0);\n///\n/// // At cold temperature (0°C) - 25°C below nominal\n/// // Capacity reduced by 25 * 0.005 = 12.5%\n/// let cold_soc = compensate_temperature(50.0, 0.0, 25.0, 0.005);\n/// assert!(cold_soc \u003c 50.0); // SOC decreases in cold\n///\n/// // At warm temperature (35°C) - 10°C above nominal\n/// let warm_soc = compensate_temperature(50.0, 35.0, 25.0, 0.005);\n/// assert!(warm_soc \u003e= 50.0); // SOC may increase slightly in warmth\n/// ```\n#[inline]\npub fn compensate_temperature(\n    soc: f32,\n    temperature: f32,\n    nominal_temp: f32,\n    coefficient: f32,\n) -\u003e f32 {\n    // Validate inputs - return original SOC if invalid\n    if !soc.is_finite()\n        || !temperature.is_finite()\n        || !nominal_temp.is_finite()\n        || !coefficient.is_finite()\n    {\n        return soc;\n    }\n\n    let delta_temp = temperature - nominal_temp;\n\n    // Calculate capacity factor based on temperature difference\n    // Below nominal: capacity decreases (factor \u003c 1.0)\n    // Above nominal: capacity increases slightly (factor \u003e 1.0, but capped)\n    let capacity_change = if delta_temp \u003c 0.0 {\n        // Cold: reduce capacity (more aggressive effect)\n        delta_temp * coefficient\n    } else {\n        // Warm: slight capacity increase (less aggressive, capped at 5%)\n        (delta_temp * coefficient * 0.5).min(0.05)\n    };\n\n    // Apply compensation: cold reduces SOC, warm increases SOC slightly\n    // Bound the total compensation to reasonable limits (-30% to +5%)\n    let bounded_change = clamp(capacity_change, -0.30, 0.05);\n\n    soc * (1.0 + bounded_change)\n}\n\n/// Applies aging compensation to SOC value\n///\n/// Battery capacity degrades over time due to chemical aging.\n/// This function adjusts the estimated SOC to account for capacity loss.\n///\n/// # Arguments\n///\n/// * `soc` - Base SOC percentage (0.0 to 100.0)\n/// * `age_years` - Battery age in years (must be non-negative)\n/// * `aging_factor` - Aging factor (capacity loss per year, e.g., 0.02 = 2%/year)\n///\n/// # Returns\n///\n/// Age-compensated SOC percentage, or the original SOC if inputs are invalid\n///\n/// # Behavior\n///\n/// - New battery (0 years): No adjustment\n/// - Aged battery: SOC appears lower due to reduced capacity\n/// - Maximum compensation is 50% (to prevent unrealistic values)\n/// - Invalid inputs (NaN, Infinity, negative age) return original SOC\n///\n/// # Examples\n///\n/// ```\n/// use battery_estimator::compensate_aging;\n///\n/// // New battery\n/// let soc = compensate_aging(50.0, 0.0, 0.02);\n/// assert_eq!(soc, 50.0);\n///\n/// // 2-year-old battery\n/// let aged_soc = compensate_aging(50.0, 2.0, 0.02);\n/// assert!(aged_soc \u003c 50.0); // Reduced by ~4%\n/// ```\n#[inline]\npub fn compensate_aging(soc: f32, age_years: f32, aging_factor: f32) -\u003e f32 {\n    // Validate inputs - return original SOC if invalid\n    if !soc.is_finite() || !age_years.is_finite() || !aging_factor.is_finite() {\n        return soc;\n    }\n\n    // Negative age doesn't make sense, treat as no aging\n    if age_years \u003c 0.0 {\n        return soc;\n    }\n\n    // Negative aging factor doesn't make sense, treat as no aging\n    if aging_factor \u003c 0.0 {\n        return soc;\n    }\n\n    let age_compensation = age_years * aging_factor;\n    soc * (1.0 - clamp(age_compensation, 0.0, 0.5)) // Max 50% compensation\n}\n\n/// Applies default temperature compensation\n///\n/// This is a convenience function that uses standard default values:\n/// - Nominal temperature: 25°C\n/// - Temperature coefficient: 0.005 (0.5% capacity loss per °C below nominal)\n///\n/// # Arguments\n///\n/// * `soc` - Base SOC percentage (0.0 to 100.0)\n/// * `temperature` - Current battery temperature in Celsius\n///\n/// # Returns\n///\n/// Temperature-compensated SOC percentage using default parameters\n///\n/// # Examples\n///\n/// ```\n/// use battery_estimator::default_temperature_compensation;\n///\n/// // At room temperature (25°C) - no change\n/// let soc = default_temperature_compensation(50.0, 25.0);\n/// assert_eq!(soc, 50.0);\n///\n/// // At cold temperature (0°C) - capacity reduced\n/// let cold_soc = default_temperature_compensation(50.0, 0.0);\n/// assert!(cold_soc \u003c 50.0); // SOC decreases in cold\n/// ```\n#[inline]\npub fn default_temperature_compensation(soc: f32, temperature: f32) -\u003e f32 {\n    const NOMINAL_TEMP: f32 = 25.0;\n    const COEFFICIENT: f32 = 0.005; // 0.5% capacity loss per °C below nominal\n\n    compensate_temperature(soc, temperature, NOMINAL_TEMP, COEFFICIENT)\n}\n\n/// Clamps a value between minimum and maximum bounds\n///\n/// # Arguments\n///\n/// * `value` - Value to clamp\n/// * `min` - Minimum allowed value\n/// * `max` - Maximum allowed value\n///\n/// # Returns\n///\n/// Clamped value within [min, max] range\nfn clamp(value: f32, min: f32, max: f32) -\u003e f32 {\n    value.clamp(min, max)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_temperature_compensation_at_nominal() {\n        // Room temperature (25°C) should have no change\n        assert_eq!(default_temperature_compensation(50.0, 25.0), 50.0);\n        assert_eq!(compensate_temperature(50.0, 25.0, 25.0, 0.005), 50.0);\n    }\n\n    #[test]\n    fn test_temperature_compensation_cold() {\n        // Cold temperature should DECREASE SOC (less usable capacity)\n        let cold_compensated = default_temperature_compensation(50.0, 0.0);\n        assert!(\n            cold_compensated \u003c 50.0,\n            \"Cold should decrease SOC due to reduced capacity\"\n        );\n\n        // At 0°C (25°C below nominal), with 0.5%/°C coefficient:\n        // Expected: 50.0 * (1.0 - 0.125) = 43.75\n        let expected = 50.0 * (1.0 + (-25.0 * 0.005));\n        assert!(\n            (cold_compensated - expected).abs() \u003c 0.01,\n            \"Cold compensation calculation mismatch\"\n        );\n    }\n\n    #[test]\n    fn test_temperature_compensation_warm() {\n        // Warm temperature should slightly INCREASE SOC (better efficiency)\n        let warm_compensated = default_temperature_compensation(50.0, 35.0);\n        assert!(\n            warm_compensated \u003e= 50.0,\n            \"Warm should increase or maintain SOC\"\n        );\n    }\n\n    #[test]\n    fn test_temperature_compensation_bounds() {\n        // Test boundary limits\n        // Extreme cold: should be limited to -30% max\n        let extreme_cold = default_temperature_compensation(50.0, -100.0);\n        assert!(\n            extreme_cold \u003e= 50.0 * 0.70,\n            \"Extreme cold should be limited to -30%\"\n        );\n\n        // Extreme hot: should be limited to +5% max\n        let extreme_hot = default_temperature_compensation(50.0, 150.0);\n        assert!(\n            extreme_hot \u003c= 50.0 * 1.05,\n            \"Extreme hot should be limited to +5%\"\n        );\n    }\n\n    #[test]\n    fn test_aging_compensation_invalid_inputs() {\n        // Test NaN input for soc\n        let nan_soc = compensate_aging(f32::NAN, 1.0, 0.02);\n        assert!(nan_soc.is_nan(), \"NaN SOC should return NaN\");\n\n        // Test Infinity input for age_years\n        let inf_age = compensate_aging(50.0, f32::INFINITY, 0.02);\n        assert_eq!(inf_age, 50.0, \"Infinity age should return original SOC\");\n\n        // Test NaN input for aging_factor\n        let nan_factor = compensate_aging(50.0, 1.0, f32::NAN);\n        assert_eq!(\n            nan_factor, 50.0,\n            \"NaN aging_factor should return original SOC\"\n        );\n    }\n\n    #[test]\n    fn test_aging_compensation_negative_age() {\n        // Negative age should be treated as no aging\n        let negative_age = compensate_aging(50.0, -1.0, 0.02);\n        assert_eq!(\n            negative_age, 50.0,\n            \"Negative age should return original SOC\"\n        );\n    }\n\n    #[test]\n    fn test_aging_compensation_negative_factor() {\n        // Negative aging factor should be treated as no aging\n        let negative_factor = compensate_aging(50.0, 1.0, -0.02);\n        assert_eq!(\n            negative_factor, 50.0,\n            \"Negative aging_factor should return original SOC\"\n        );\n    }\n\n    #[test]\n    fn test_temperature_compensation_invalid_inputs() {\n        // Test NaN inputs\n        let nan_soc = compensate_temperature(f32::NAN, 25.0, 25.0, 0.005);\n        assert!(nan_soc.is_nan(), \"NaN SOC should return NaN\");\n\n        let nan_temp = compensate_temperature(50.0, f32::NAN, 25.0, 0.005);\n        assert_eq!(nan_temp, 50.0, \"NaN temperature should return original SOC\");\n\n        let nan_nominal = compensate_temperature(50.0, 25.0, f32::NAN, 0.005);\n        assert_eq!(\n            nan_nominal, 50.0,\n            \"NaN nominal_temp should return original SOC\"\n        );\n\n        let nan_coeff = compensate_temperature(50.0, 25.0, 25.0, f32::NAN);\n        assert_eq!(\n            nan_coeff, 50.0,\n            \"NaN coefficient should return original SOC\"\n        );\n\n        // Test Infinity inputs\n        let inf_temp = compensate_temperature(50.0, f32::INFINITY, 25.0, 0.005);\n        assert_eq!(\n            inf_temp, 50.0,\n            \"Infinity temperature should return original SOC\"\n        );\n    }\n\n    #[test]\n    fn test_aging_compensation() {\n        // New battery should have no change\n        assert_eq!(compensate_aging(50.0, 0.0, 0.02), 50.0);\n\n        // Aged battery should decrease SOC\n        let aged = compensate_aging(50.0, 5.0, 0.02);\n        assert!(aged \u003c 50.0, \"Aging should decrease SOC\");\n\n        // Test maximum 50% compensation\n        let very_aged = compensate_aging(50.0, 30.0, 0.02);\n        assert!(\n            very_aged \u003e= 25.0,\n            \"Should be limited to 50% max compensation\"\n        );\n    }\n\n    #[test]\n    fn test_temperature_compensation_different_coefficients() {\n        let base_soc = 50.0;\n        let temp = 0.0; // 25°C below nominal (cold)\n        let nominal = 25.0;\n\n        // Test with different temperature coefficients\n        // In cold conditions, higher coefficient = more capacity loss = lower SOC\n        let result1 = compensate_temperature(base_soc, temp, nominal, 0.005);\n        let result2 = compensate_temperature(base_soc, temp, nominal, 0.010);\n        let result3 = compensate_temperature(base_soc, temp, nominal, 0.001);\n\n        // Higher coefficient should result in MORE capacity loss (lower SOC) in cold\n        assert!(\n            result2 \u003c result1,\n            \"Higher coefficient should result in lower SOC in cold (more capacity loss)\"\n        );\n        assert!(\n            result3 \u003e result1,\n            \"Lower coefficient should result in higher SOC in cold (less capacity loss)\"\n        );\n    }\n\n    #[test]\n    fn test_temperature_compensation_different_nominal_temps() {\n        let base_soc = 50.0;\n        let temp = 0.0;\n        let coefficient = 0.0005;\n\n        // Test with different nominal temperatures\n        let result1 = compensate_temperature(base_soc, temp, 25.0, coefficient);\n        let result2 = compensate_temperature(base_soc, temp, 0.0, coefficient);\n\n        // When nominal temp equals actual temp, no compensation\n        let result3 = compensate_temperature(base_soc, 25.0, 25.0, coefficient);\n        assert_eq!(result3, base_soc, \"No compensation when temps are equal\");\n\n        // Different nominal temps should result in different compensation\n        assert!(\n            result1 != result2,\n            \"Different nominal temps should give different results\"\n        );\n    }\n\n    #[test]\n    fn test_aging_compensation_different_factors() {\n        let base_soc = 50.0;\n        let age = 5.0;\n\n        // Test with different aging factors\n        let result1 = compensate_aging(base_soc, age, 0.02);\n        let result2 = compensate_aging(base_soc, age, 0.05);\n        let result3 = compensate_aging(base_soc, age, 0.01);\n\n        // Higher aging factor should result in more reduction\n        assert!(\n            result2 \u003c result1,\n            \"Higher aging factor should reduce SOC more\"\n        );\n        assert!(\n            result3 \u003e result1,\n            \"Lower aging factor should reduce SOC less\"\n        );\n    }\n\n    #[test]\n    fn test_aging_compensation_different_ages() {\n        let base_soc = 50.0;\n        let factor = 0.02;\n\n        // Test with different battery ages\n        let result1 = compensate_aging(base_soc, 1.0, factor);\n        let result2 = compensate_aging(base_soc, 5.0, factor);\n        let result3 = compensate_aging(base_soc, 10.0, factor);\n\n        // Older battery should have lower SOC\n        assert!(result2 \u003c result1, \"Older battery should have lower SOC\");\n        assert!(\n            result3 \u003c result2,\n            \"Even older battery should have even lower SOC\"\n        );\n    }\n\n    #[test]\n    fn test_aging_compensation_zero_age() {\n        // Test that zero age results in no compensation\n        let result = compensate_aging(50.0, 0.0, 0.02);\n        assert_eq!(result, 50.0, \"Zero age should result in no compensation\");\n    }\n\n    #[test]\n    fn test_aging_compensation_max_limit() {\n        // Test that aging compensation is limited to 50%\n        let base_soc = 50.0;\n\n        // Very old battery with high aging factor\n        let result = compensate_aging(base_soc, 100.0, 1.0);\n\n        // Should be limited to 50% reduction (25.0)\n        assert!(result \u003e= 25.0, \"Should be limited to 50% max compensation\");\n    }\n\n    #[test]\n    fn test_temperature_compensation_max_limit() {\n        // Test that temperature compensation is limited to ±5%\n        let base_soc = 50.0;\n\n        // Extreme temperature difference\n        let cold_result = compensate_temperature(base_soc, -200.0, 25.0, 0.0005);\n        let hot_result = compensate_temperature(base_soc, 200.0, 25.0, 0.0005);\n\n        // Cold: should be at most 5% increase (52.5)\n        assert!(\n            cold_result \u003c= 52.5,\n            \"Cold compensation should be limited to +5%\"\n        );\n\n        // Hot: should be at most 5% decrease (47.5)\n        assert!(\n            hot_result \u003e= 47.5,\n            \"Hot compensation should be limited to -5%\"\n        );\n    }\n\n    #[test]\n    fn test_compensation_edge_cases() {\n        // Test compensation at boundary SOC values\n        let zero_soc = 0.0;\n        let full_soc = 100.0;\n\n        // Temperature compensation at 0% SOC\n        let temp_comp_zero = default_temperature_compensation(zero_soc, 0.0);\n        assert_eq!(temp_comp_zero, 0.0, \"0% SOC should remain 0%\");\n\n        // Temperature compensation at 100% SOC\n        let temp_comp_full = default_temperature_compensation(full_soc, 0.0);\n        assert!(temp_comp_full \u003c= 105.0, \"100% SOC should not exceed 105%\");\n\n        // Aging compensation at 0% SOC\n        let aging_comp_zero = compensate_aging(zero_soc, 5.0, 0.02);\n        assert_eq!(aging_comp_zero, 0.0, \"0% SOC should remain 0%\");\n\n        // Aging compensation at 100% SOC\n        let aging_comp_full = compensate_aging(full_soc, 5.0, 0.02);\n        assert!(aging_comp_full \u003c= 100.0, \"100% SOC should not exceed 100%\");\n    }\n\n    #[test]\n    fn test_temperature_compensation_fractional_values() {\n        // Test with fractional SOC values\n        let fractional_soc = 37.5;\n\n        let result = default_temperature_compensation(fractional_soc, 10.0);\n        assert!(result.is_finite(), \"Result should be finite\");\n        assert!(result \u003e= 0.0, \"Result should be non-negative\");\n    }\n\n    #[test]\n    fn test_aging_compensation_fractional_values() {\n        // Test with fractional age and factor values\n        let result = compensate_aging(50.0, 2.5, 0.015);\n        assert!(result.is_finite(), \"Result should be finite\");\n        assert!(result \u003e= 0.0, \"Result should be non-negative\");\n        assert!(result \u003c 50.0, \"Result should be less than base SOC\");\n    }\n\n    #[test]\n    fn test_compensation_negative_coefficient() {\n        // Test with negative temperature coefficient (unusual but possible)\n        let result = compensate_temperature(50.0, 0.0, 25.0, -0.0005);\n        assert!(result.is_finite(), \"Result should be finite\");\n    }\n\n    #[test]\n    fn test_compensation_zero_coefficient() {\n        // Test with zero coefficient (should result in no change)\n        let result = compensate_temperature(50.0, 0.0, 25.0, 0.0);\n        assert_eq!(result, 50.0, \"Zero coefficient should result in no change\");\n    }\n\n    #[test]\n    fn test_aging_compensation_zero_factor() {\n        // Test with zero aging factor (should result in no change)\n        let result = compensate_aging(50.0, 5.0, 0.0);\n        assert_eq!(result, 50.0, \"Zero aging factor should result in no change\");\n    }\n\n    #[test]\n    fn test_temperature_compensation_precision() {\n        // Test that compensation maintains reasonable precision\n        let base_soc = 50.123456;\n        let result = default_temperature_compensation(base_soc, 25.0);\n\n        // At nominal temperature, should be very close to original\n        assert!(\n            (result - base_soc).abs() \u003c 0.001,\n            \"Should maintain precision\"\n        );\n    }\n\n    #[test]\n    fn test_combined_compensation_effects() {\n        // Test that temperature and aging can be applied sequentially\n        let base_soc = 50.0;\n\n        // Apply temperature compensation\n        let temp_comp = default_temperature_compensation(base_soc, 0.0);\n\n        // Apply aging compensation to the result\n        let final_comp = compensate_aging(temp_comp, 5.0, 0.02);\n\n        // Both should have been applied\n        assert!(final_comp.is_finite(), \"Result should be finite\");\n        assert!(\n            (0.0..=100.0).contains(\u0026final_comp),\n            \"Result should be in valid range\"\n        );\n    }\n\n    #[test]\n    fn test_clamp_function() {\n        // Test clamping at upper bound (warm temperature, +5% max)\n        let result = compensate_temperature(50.0, 1000.0, 25.0, 0.005);\n        assert!(result \u003c= 52.5, \"Should be clamped to +5%\");\n\n        // Test clamping at lower bound (cold temperature, -30% max)\n        let result = compensate_temperature(50.0, -1000.0, 25.0, 0.005);\n        assert!(result \u003e= 35.0, \"Should be clamped to -30%\");\n\n        // Test that extreme cold is properly bounded\n        let result = compensate_temperature(50.0, -100.0, 25.0, 0.005);\n        assert!(result \u003e= 35.0, \"Extreme cold should be at lower bound\");\n    }\n}\n","traces":[{"line":57,"address":[527552],"length":1,"stats":{"Line":5},"fn_name":"compensate_temperature"},{"line":64,"address":[527604],"length":1,"stats":{"Line":5},"fn_name":null},{"line":65,"address":[527633],"length":1,"stats":{"Line":10},"fn_name":null},{"line":66,"address":[527650],"length":1,"stats":{"Line":10},"fn_name":null},{"line":67,"address":[527667],"length":1,"stats":{"Line":11},"fn_name":null},{"line":69,"address":[527619],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[527690],"length":1,"stats":{"Line":11},"fn_name":null},{"line":77,"address":[527706],"length":1,"stats":{"Line":11},"fn_name":null},{"line":79,"address":[527788],"length":1,"stats":{"Line":10},"fn_name":null},{"line":82,"address":[527739],"length":1,"stats":{"Line":3},"fn_name":null},{"line":87,"address":[527798],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[527840],"length":1,"stats":{"Line":13},"fn_name":null},{"line":128,"address":[527312],"length":1,"stats":{"Line":10},"fn_name":"compensate_aging"},{"line":130,"address":[527352,527381],"length":1,"stats":{"Line":19},"fn_name":null},{"line":131,"address":[527367],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[527415],"length":1,"stats":{"Line":9},"fn_name":null},{"line":136,"address":[527458],"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[527442],"length":1,"stats":{"Line":4},"fn_name":null},{"line":141,"address":[527543],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[527478],"length":1,"stats":{"Line":7},"fn_name":null},{"line":145,"address":[527488],"length":1,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[527872],"length":1,"stats":{"Line":5},"fn_name":"default_temperature_compensation"},{"line":181,"address":[527884],"length":1,"stats":{"Line":5},"fn_name":null},{"line":195,"address":[527920],"length":1,"stats":{"Line":2},"fn_name":"clamp"},{"line":196,"address":[527942],"length":1,"stats":{"Line":20},"fn_name":null}],"covered":25,"coverable":25},{"path":["/","home","kingingwang","workspace","rust","battery-estimator","src","curve.rs"],"content":"//! Voltage-SOC curve definitions and interpolation\n//!\n//! This module provides the [`Curve`] struct for representing battery\n//! discharge curves and converting voltage measurements to state-of-charge (SOC) values.\n\nuse crate::{CurvePoint, Error};\n\n/// Maximum number of points allowed in a voltage curve\n///\n/// This limit ensures predictable memory usage and prevents excessive\n/// curve sizes that could impact performance in embedded systems.\npub const MAX_CURVE_POINTS: usize = 32;\n\n/// A voltage-to-SOC curve for battery state-of-charge estimation\n///\n/// This struct represents a discharge curve that maps battery voltage\n/// to state-of-charge percentage using linear interpolation between data points.\n///\n/// # Memory Optimization\n///\n/// The curve is stored using fixed-size arrays with optimized types:\n/// - `points`: Fixed array of 32 points\n/// - `len`: `u8` for point count (vs `usize`, saves memory)\n/// - `min_voltage_mv`/`max_voltage_mv`: `u16` for voltage limits\n/// - `min_soc_tenth`/`max_soc_tenth`: `u16` for cached SOC values (tenth of percent)\n///\n/// # Examples\n///\n/// ```no_run\n/// use battery_estimator::{Curve, CurvePoint};\n///\n/// // Create a custom curve\n/// const CUSTOM_CURVE: Curve = Curve::new(\u0026[\n///     CurvePoint::new(3.0, 0.0),\n///     CurvePoint::new(3.5, 50.0),\n///     CurvePoint::new(4.0, 100.0),\n/// ]);\n///\n/// // Use the curve\n/// match CUSTOM_CURVE.voltage_to_soc(3.75) {\n///     Ok(soc) =\u003e println!(\"SOC: {:.1}%\", soc),\n///     Err(e) =\u003e eprintln!(\"Error: {}\", e),\n/// }\n/// ```\n///\n/// # Interpolation\n///\n/// The curve uses linear interpolation between points:\n/// - Values at or below minimum voltage → Returns min SOC\n/// - Values at or above maximum voltage → Returns max SOC\n/// - Values between points → Linear interpolation\n#[derive(Debug, Clone, Copy)]\npub struct Curve {\n    /// Array of curve points (fixed size for memory efficiency)\n    points: [CurvePoint; MAX_CURVE_POINTS],\n\n    /// Number of points in the curve (0-255)\n    len: u8,\n\n    /// Minimum voltage in millivolts\n    min_voltage_mv: u16,\n\n    /// Maximum voltage in millivolts\n    max_voltage_mv: u16,\n\n    /// SOC at minimum voltage (cached in tenths of percent)\n    min_soc_tenth: u16,\n\n    /// SOC at maximum voltage (cached in tenths of percent)\n    max_soc_tenth: u16,\n}\n\nimpl Curve {\n    /// Creates an empty curve with no points\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use battery_estimator::Curve;\n    ///\n    /// let empty = Curve::empty();\n    /// assert!(empty.is_empty());\n    /// assert_eq!(empty.len(), 0);\n    /// ```\n    pub const fn empty() -\u003e Self {\n        Self {\n            points: [CurvePoint::new(0.0, 0.0); MAX_CURVE_POINTS],\n            len: 0,\n            min_voltage_mv: 0,\n            max_voltage_mv: 0,\n            min_soc_tenth: 0,\n            max_soc_tenth: 0,\n        }\n    }\n\n    /// Creates a new curve from a slice of points\n    ///\n    /// # Arguments\n    ///\n    /// * `points` - Slice of [`CurvePoint`] values, ordered by increasing voltage\n    ///\n    /// # Notes\n    ///\n    /// - Points must be ordered by increasing voltage\n    /// - Maximum of 32 points will be stored\n    /// - Minimum of 2 points required for valid interpolation\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use battery_estimator::{Curve, CurvePoint};\n    ///\n    /// let curve = Curve::new(\u0026[\n    ///     CurvePoint::new(3.0, 0.0),\n    ///     CurvePoint::new(3.5, 50.0),\n    ///     CurvePoint::new(4.0, 100.0),\n    /// ]);\n    /// ```\n    pub const fn new(points: \u0026[CurvePoint]) -\u003e Self {\n        let mut curve = Self::empty();\n        let mut i = 0usize;\n\n        let mut min = 0u16;\n        let mut max = 0u16;\n        let mut min_soc = 0u16;\n        let mut max_soc = 0u16;\n\n        while i \u003c points.len() \u0026\u0026 i \u003c MAX_CURVE_POINTS {\n            let p = points[i];\n            curve.points[i] = p;\n\n            if i == 0 {\n                min = p.voltage_mv;\n                max = p.voltage_mv;\n                min_soc = p.soc_tenth;\n                max_soc = p.soc_tenth;\n            } else {\n                if p.voltage_mv \u003c min {\n                    min = p.voltage_mv;\n                    min_soc = p.soc_tenth;\n                }\n                if p.voltage_mv \u003e max {\n                    max = p.voltage_mv;\n                    max_soc = p.soc_tenth;\n                }\n            }\n\n            i += 1;\n        }\n\n        curve.len = i as u8;\n        if i \u003e 0 {\n            curve.min_voltage_mv = min;\n            curve.max_voltage_mv = max;\n            curve.min_soc_tenth = min_soc;\n            curve.max_soc_tenth = max_soc;\n        }\n        curve\n    }\n\n    /// Converts a voltage measurement to state-of-charge (SOC) percentage\n    ///\n    /// # Arguments\n    ///\n    /// * `voltage` - Battery voltage in volts\n    ///\n    /// # Returns\n    ///\n    /// * `Ok(soc)` - SOC percentage (0.0 to 100.0)\n    /// * `Err(Error::InvalidCurve)` - Curve has fewer than 2 points\n    /// * `Err(Error::NumericalError)` - Division by zero or calculation error\n    ///\n    /// # Behavior\n    ///\n    /// - Voltage ≤ minimum → Returns min SOC\n    /// - Voltage ≥ maximum → Returns max SOC\n    /// - Voltage between points → Linear interpolation\n    ///\n    /// # Performance\n    ///\n    /// This method uses binary search (via `partition_point`) for O(log n) lookup\n    /// and cached SOC values for O(1) boundary checks.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use battery_estimator::{Curve, CurvePoint};\n    ///\n    /// let curve = Curve::new(\u0026[\n    ///     CurvePoint::new(3.0, 0.0),\n    ///     CurvePoint::new(3.5, 50.0),\n    ///     CurvePoint::new(4.0, 100.0),\n    /// ]);\n    ///\n    /// // At minimum voltage\n    /// assert_eq!(curve.voltage_to_soc(3.0).unwrap(), 0.0);\n    ///\n    /// // At maximum voltage\n    /// assert_eq!(curve.voltage_to_soc(4.0).unwrap(), 100.0);\n    ///\n    /// // Midpoint interpolation\n    /// assert_eq!(curve.voltage_to_soc(3.5).unwrap(), 50.0);\n    /// ```\n    pub fn voltage_to_soc(\u0026self, voltage: f32) -\u003e Result\u003cf32, Error\u003e {\n        if self.len \u003c 2 {\n            return Err(Error::InvalidCurve);\n        }\n\n        let voltage_mv = (voltage * 1000.0) as i32;\n\n        // Boundary checks - use cached SOC values for O(1) lookup\n        if voltage_mv \u003e= self.max_voltage_mv as i32 {\n            return Ok(self.max_soc_tenth as f32 / 10.0);\n        }\n        if voltage_mv \u003c= self.min_voltage_mv as i32 {\n            return Ok(self.min_soc_tenth as f32 / 10.0);\n        }\n\n        // Binary search for interpolation segment using Rust's partition_point\n        let points = \u0026self.points[..self.len as usize];\n\n        // Find the index of the first point with voltage \u003e target voltage\n        let idx = points.partition_point(|p| p.voltage_mv as i32 \u003c= voltage_mv);\n\n        // Check if we found a valid interpolation segment\n        if idx \u003e 0 \u0026\u0026 idx \u003c points.len() {\n            let prev = points[idx - 1];\n            let curr = points[idx];\n\n            if voltage_mv \u003e= prev.voltage_mv as i32 \u0026\u0026 voltage_mv \u003c= curr.voltage_mv as i32 {\n                let range = (curr.voltage_mv as i32 - prev.voltage_mv as i32) as f32;\n                let ratio = (voltage_mv - prev.voltage_mv as i32) as f32 / range;\n                let soc = prev.soc() + ratio * (curr.soc() - prev.soc());\n                return Ok(soc);\n            }\n        }\n\n        Err(Error::NumericalError)\n    }\n\n    /// Returns the voltage range of the curve\n    ///\n    /// # Returns\n    ///\n    /// Tuple of (minimum_voltage, maximum_voltage) in volts\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use battery_estimator::{Curve, CurvePoint};\n    ///\n    /// let curve = Curve::new(\u0026[\n    ///     CurvePoint::new(3.0, 0.0),\n    ///     CurvePoint::new(4.0, 100.0),\n    /// ]);\n    ///\n    /// let (min, max) = curve.voltage_range();\n    /// assert_eq!(min, 3.0);\n    /// assert_eq!(max, 4.0);\n    /// ```\n    #[inline]\n    pub const fn voltage_range(\u0026self) -\u003e (f32, f32) {\n        (\n            self.min_voltage_mv as f32 / 1000.0,\n            self.max_voltage_mv as f32 / 1000.0,\n        )\n    }\n\n    /// Returns the number of points in the curve\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use battery_estimator::{Curve, CurvePoint};\n    ///\n    /// let curve = Curve::new(\u0026[\n    ///     CurvePoint::new(3.0, 0.0),\n    ///     CurvePoint::new(3.5, 50.0),\n    ///     CurvePoint::new(4.0, 100.0),\n    /// ]);\n    ///\n    /// assert_eq!(curve.len(), 3);\n    /// ```\n    #[inline]\n    pub const fn len(\u0026self) -\u003e usize {\n        self.len as usize\n    }\n\n    /// Returns `true` if the curve has no points\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use battery_estimator::Curve;\n    ///\n    /// let empty = Curve::empty();\n    /// assert!(empty.is_empty());\n    /// ```\n    #[inline]\n    pub const fn is_empty(\u0026self) -\u003e bool {\n        self.len == 0\n    }\n}\n\n/// Predefined battery voltage curves\n///\n/// This module contains built-in voltage curves for common battery types.\n/// These curves are optimized for typical discharge characteristics.\npub mod default_curves {\n    use super::*;\n\n    /// Standard Lithium Polymer (LiPo) battery curve\n    ///\n    /// - Full charge: 4.2V\n    /// - Cutoff: 3.2V\n    /// - Nominal: 3.7V\n    /// - Points: 10\n    pub const LIPO: Curve = Curve::new(\u0026[\n        CurvePoint::new(3.20, 0.0),\n        CurvePoint::new(3.30, 5.0),\n        CurvePoint::new(3.40, 10.0),\n        CurvePoint::new(3.50, 20.0),\n        CurvePoint::new(3.60, 30.0),\n        CurvePoint::new(3.70, 50.0),\n        CurvePoint::new(3.80, 70.0),\n        CurvePoint::new(3.90, 85.0),\n        CurvePoint::new(4.00, 95.0),\n        CurvePoint::new(4.20, 100.0),\n    ]);\n\n    /// Lithium Iron Phosphate (LiFePO4) battery curve\n    ///\n    /// - Full charge: 3.65V\n    /// - Cutoff: 3.0V\n    /// - Nominal: 3.2V\n    /// - Points: 10\n    /// - Features: Very flat discharge curve, long cycle life\n    pub const LIFEPO4: Curve = Curve::new(\u0026[\n        CurvePoint::new(2.50, 0.0),\n        CurvePoint::new(2.80, 15.0),\n        CurvePoint::new(3.00, 35.0),\n        CurvePoint::new(3.10, 45.0),\n        CurvePoint::new(3.20, 55.0),\n        CurvePoint::new(3.30, 65.0),\n        CurvePoint::new(3.40, 75.0),\n        CurvePoint::new(3.50, 85.0),\n        CurvePoint::new(3.60, 95.0),\n        CurvePoint::new(3.65, 100.0),\n    ]);\n\n    /// Standard Lithium Ion (Li-Ion) battery curve\n    ///\n    /// - Full charge: 4.2V\n    /// - Cutoff: 3.3V\n    /// - Nominal: 3.7V\n    /// - Points: 11\n    pub const LIION: Curve = Curve::new(\u0026[\n        CurvePoint::new(2.50, 0.0),\n        CurvePoint::new(3.00, 30.0),\n        CurvePoint::new(3.30, 50.0),\n        CurvePoint::new(3.50, 65.0),\n        CurvePoint::new(3.60, 70.0),\n        CurvePoint::new(3.70, 75.0),\n        CurvePoint::new(3.80, 80.0),\n        CurvePoint::new(3.90, 85.0),\n        CurvePoint::new(4.00, 90.0),\n        CurvePoint::new(4.10, 95.0),\n        CurvePoint::new(4.20, 100.0),\n    ]);\n\n    /// Conservative LiPo curve for extended battery life\n    ///\n    /// - Full charge: 4.1V (lower than standard 4.2V)\n    /// - Cutoff: 3.4V (higher than standard 3.2V)\n    /// - Nominal: 3.77V\n    /// - Points: 13\n    ///\n    /// # Use Case\n    ///\n    /// This curve prioritizes battery longevity over maximum capacity:\n    /// - **Lower charge voltage** (4.1V) reduces charging stress\n    /// - **Higher cutoff** (3.4V) prevents deep discharge\n    /// - **Trade-off**: ~15-20% less usable capacity for ~30% longer cycle life\n    ///\n    /// # When to Use\n    ///\n    /// - Applications where battery replacement is difficult\n    /// - Devices requiring very long service life\n    /// - Systems prioritizing reliability over runtime\n    pub const LIPO410_FULL340_CUTOFF: Curve = Curve::new(\u0026[\n        CurvePoint::new(3.40, 0.0),\n        CurvePoint::new(3.48, 5.0),\n        CurvePoint::new(3.53, 10.0),\n        CurvePoint::new(3.62, 20.0),\n        CurvePoint::new(3.68, 30.0),\n        CurvePoint::new(3.73, 40.0),\n        CurvePoint::new(3.77, 50.0),\n        CurvePoint::new(3.81, 60.0),\n        CurvePoint::new(3.85, 70.0),\n        CurvePoint::new(3.90, 80.0),\n        CurvePoint::new(3.97, 90.0),\n        CurvePoint::new(4.03, 95.0),\n        CurvePoint::new(4.10, 100.0),\n    ]);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_curve_basic() {\n        let curve = Curve::new(\u0026[CurvePoint::new(3.0, 0.0), CurvePoint::new(4.0, 100.0)]);\n\n        assert_eq!(curve.voltage_to_soc(3.0).unwrap(), 0.0);\n        assert_eq!(curve.voltage_to_soc(4.0).unwrap(), 100.0);\n        assert_eq!(curve.voltage_to_soc(3.5).unwrap(), 50.0);\n    }\n\n    #[test]\n    fn test_curve_boundaries() {\n        let curve = Curve::new(\u0026[\n            CurvePoint::new(3.0, 0.0),\n            CurvePoint::new(3.5, 50.0),\n            CurvePoint::new(4.0, 100.0),\n        ]);\n\n        // Test boundaries\n        assert_eq!(curve.voltage_to_soc(2.9).unwrap(), 0.0);\n        assert_eq!(curve.voltage_to_soc(4.1).unwrap(), 100.0);\n\n        // Test intermediate values\n        assert_eq!(curve.voltage_to_soc(3.25).unwrap(), 25.0);\n        assert_eq!(curve.voltage_to_soc(3.75).unwrap(), 75.0);\n    }\n\n    #[test]\n    fn test_curve_invalid() {\n        let curve = Curve::new(\u0026[CurvePoint::new(3.0, 0.0)]);\n\n        // Curve with only one point should error\n        assert!(curve.voltage_to_soc(3.5).is_err());\n    }\n\n    #[test]\n    fn test_curve_empty() {\n        let curve = Curve::empty();\n        assert!(curve.is_empty());\n        assert_eq!(curve.len(), 0);\n        assert!(curve.voltage_to_soc(3.0).is_err());\n    }\n\n    #[test]\n    fn test_curve_multiple_points() {\n        let curve = Curve::new(\u0026[\n            CurvePoint::new(3.0, 0.0),\n            CurvePoint::new(3.5, 50.0),\n            CurvePoint::new(4.0, 100.0),\n        ]);\n\n        assert_eq!(curve.len(), 3);\n\n        // Test exact points\n        assert_eq!(curve.voltage_to_soc(3.0).unwrap(), 0.0);\n        assert_eq!(curve.voltage_to_soc(3.5).unwrap(), 50.0);\n        assert_eq!(curve.voltage_to_soc(4.0).unwrap(), 100.0);\n\n        // Test interpolation\n        let soc = curve.voltage_to_soc(3.25).unwrap();\n        assert!((soc - 25.0).abs() \u003c 0.1);\n\n        let soc = curve.voltage_to_soc(3.75).unwrap();\n        assert!((soc - 75.0).abs() \u003c 0.1);\n    }\n\n    #[test]\n    fn test_curve_voltage_range() {\n        let curve = Curve::new(\u0026[CurvePoint::new(3.0, 0.0), CurvePoint::new(4.0, 100.0)]);\n\n        let (min, max) = curve.voltage_range();\n        assert_eq!(min, 3.0);\n        assert_eq!(max, 4.0);\n    }\n\n    #[test]\n    fn test_curve_max_points() {\n        // Test that curve handles maximum number of points\n        let mut points = [CurvePoint::new(0.0, 0.0); MAX_CURVE_POINTS];\n        for (i, point) in points.iter_mut().enumerate().take(MAX_CURVE_POINTS) {\n            let voltage = 3.0 + (i as f32 * 0.1);\n            let soc = (i as f32 / (MAX_CURVE_POINTS - 1) as f32) * 100.0;\n            *point = CurvePoint::new(voltage, soc);\n        }\n\n        let curve = Curve::new(\u0026points);\n        assert_eq!(curve.len(), MAX_CURVE_POINTS);\n\n        // Test interpolation at various points\n        assert!(curve.voltage_to_soc(3.5).is_ok());\n    }\n\n    #[test]\n    fn test_curve_numerical_error_fallback() {\n        // Test the fallback NumericalError path when voltage is not found in any segment\n        // This can happen with non-monotonic/decreasing voltage curves\n        // The curve stores points in order, but with decreasing voltages\n        // so the linear search won't find a valid segment\n        let curve = Curve::new(\u0026[\n            CurvePoint::new(3.0, 0.0),\n            CurvePoint::new(2.5, 50.0), // Decreasing voltage\n            CurvePoint::new(2.0, 100.0),\n        ]);\n\n        // Voltage 2.7 is between 3.0 and 2.5 but not in increasing order\n        // This should trigger NumericalError\n        assert!(matches!(\n            curve.voltage_to_soc(2.7),\n            Err(Error::NumericalError)\n        ));\n    }\n\n    #[test]\n    fn test_curve_cached_soc_values() {\n        // Test that cached SOC values are correctly computed\n        let curve = Curve::new(\u0026[\n            CurvePoint::new(3.0, 5.0), // Non-zero min SOC\n            CurvePoint::new(3.5, 50.0),\n            CurvePoint::new(4.0, 95.0), // Non-100 max SOC\n        ]);\n\n        // At min voltage, should return cached min SOC (5.0%)\n        assert_eq!(curve.voltage_to_soc(3.0).unwrap(), 5.0);\n\n        // Below min voltage, should still return cached min SOC\n        assert_eq!(curve.voltage_to_soc(2.5).unwrap(), 5.0);\n\n        // At max voltage, should return cached max SOC (95.0%)\n        assert_eq!(curve.voltage_to_soc(4.0).unwrap(), 95.0);\n\n        // Above max voltage, should still return cached max SOC\n        assert_eq!(curve.voltage_to_soc(4.5).unwrap(), 95.0);\n    }\n\n    #[test]\n    fn test_curve_interpolation_precision() {\n        let curve = Curve::new(\u0026[\n            CurvePoint::new(3.0, 0.0),\n            CurvePoint::new(3.1, 10.0),\n            CurvePoint::new(3.2, 20.0),\n            CurvePoint::new(3.3, 30.0),\n        ]);\n\n        // Test precise interpolation\n        assert_eq!(curve.voltage_to_soc(3.05).unwrap(), 5.0);\n        assert_eq!(curve.voltage_to_soc(3.15).unwrap(), 15.0);\n        assert_eq!(curve.voltage_to_soc(3.25).unwrap(), 25.0);\n    }\n\n    #[test]\n    fn test_curve_single_segment() {\n        let curve = Curve::new(\u0026[CurvePoint::new(3.0, 0.0), CurvePoint::new(4.0, 100.0)]);\n\n        // Single segment interpolation\n        assert_eq!(curve.voltage_to_soc(3.25).unwrap(), 25.0);\n        assert_eq!(curve.voltage_to_soc(3.5).unwrap(), 50.0);\n        assert_eq!(curve.voltage_to_soc(3.75).unwrap(), 75.0);\n    }\n\n    #[test]\n    fn test_curve_dense_points() {\n        // Test with many closely spaced points - use array for no_std compatibility\n        let points: [CurvePoint; 21] =\n            core::array::from_fn(|i| CurvePoint::new(3.0 + i as f32 * 0.05, i as f32 * 5.0));\n\n        let curve = Curve::new(\u0026points);\n\n        // Test that interpolation works with dense points\n        for i in 0..20 {\n            let voltage = 3.0 + i as f32 * 0.05 + 0.025;\n            let expected_soc = i as f32 * 5.0 + 2.5;\n            assert!((curve.voltage_to_soc(voltage).unwrap() - expected_soc).abs() \u003c 0.01);\n        }\n    }\n\n    #[test]\n    fn test_curve_non_linear() {\n        // Test with non-linear curve (exponential-like)\n        let curve = Curve::new(\u0026[\n            CurvePoint::new(3.0, 0.0),\n            CurvePoint::new(3.5, 20.0),\n            CurvePoint::new(4.0, 60.0),\n            CurvePoint::new(4.2, 100.0),\n        ]);\n\n        // Verify non-linear interpolation\n        let soc_35 = curve.voltage_to_soc(3.5).unwrap();\n        let soc_38 = curve.voltage_to_soc(3.8).unwrap();\n        let soc_41 = curve.voltage_to_soc(4.1).unwrap();\n\n        assert_eq!(soc_35, 20.0);\n        // 3.8V is between 3.5V (20%) and 4.0V (60%)\n        // ratio = (3.8 - 3.5) / (4.0 - 3.5) = 0.6\n        // soc = 20 + 0.6 * 40 = 44.0\n        assert!((soc_38 - 44.0).abs() \u003c 0.1);\n        // 4.1V is between 4.0V (60%) and 4.2V (100%)\n        // ratio = (4.1 - 4.0) / (4.2 - 4.0) = 0.5\n        // soc = 60 + 0.5 * 40 = 80.0\n        assert!((soc_41 - 80.0).abs() \u003c 0.1);\n    }\n}\n","traces":[{"line":78,"address":[508032],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[508049],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[507488],"length":1,"stats":{"Line":10},"fn_name":null},{"line":111,"address":[507531],"length":1,"stats":{"Line":10},"fn_name":null},{"line":112,"address":[507541],"length":1,"stats":{"Line":10},"fn_name":null},{"line":114,"address":[507553],"length":1,"stats":{"Line":10},"fn_name":null},{"line":115,"address":[507563],"length":1,"stats":{"Line":8},"fn_name":null},{"line":117,"address":[507616,507578,507999],"length":1,"stats":{"Line":30},"fn_name":null},{"line":118,"address":[507632,507798,507732],"length":1,"stats":{"Line":20},"fn_name":null},{"line":119,"address":[507826,507854,507767],"length":1,"stats":{"Line":20},"fn_name":null},{"line":121,"address":[507893,507836],"length":1,"stats":{"Line":20},"fn_name":null},{"line":122,"address":[507877],"length":1,"stats":{"Line":10},"fn_name":null},{"line":123,"address":[507885],"length":1,"stats":{"Line":10},"fn_name":null},{"line":125,"address":[507969,507900],"length":1,"stats":{"Line":10},"fn_name":null},{"line":126,"address":[507961],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[507944,507984],"length":1,"stats":{"Line":16},"fn_name":null},{"line":129,"address":[507976],"length":1,"stats":{"Line":8},"fn_name":null},{"line":133,"address":[507991,508004,507912],"length":1,"stats":{"Line":20},"fn_name":null},{"line":136,"address":[507588],"length":1,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[507720,507603],"length":1,"stats":{"Line":11},"fn_name":null},{"line":138,"address":[507688],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[507704],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[507660],"length":1,"stats":{"Line":10},"fn_name":null},{"line":182,"address":[506176],"length":1,"stats":{"Line":3},"fn_name":null},{"line":183,"address":[506211],"length":1,"stats":{"Line":5},"fn_name":null},{"line":184,"address":[506293],"length":1,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[506231],"length":1,"stats":{"Line":5},"fn_name":null},{"line":190,"address":[506278],"length":1,"stats":{"Line":5},"fn_name":null},{"line":192,"address":[506337],"length":1,"stats":{"Line":2},"fn_name":null},{"line":193,"address":[507265,506353],"length":1,"stats":{"Line":4},"fn_name":null},{"line":194,"address":[507366,507326],"length":1,"stats":{"Line":4},"fn_name":null},{"line":195,"address":[507409],"length":1,"stats":{"Line":2},"fn_name":null},{"line":199,"address":[507334],"length":1,"stats":{"Line":2},"fn_name":null},{"line":201,"address":[506313],"length":1,"stats":{"Line":6},"fn_name":null},{"line":203,"address":[506480],"length":1,"stats":{"Line":3},"fn_name":null},{"line":204,"address":[506499,507053],"length":1,"stats":{"Line":6},"fn_name":null},{"line":205,"address":[507160,507117],"length":1,"stats":{"Line":6},"fn_name":null},{"line":206,"address":[507203],"length":1,"stats":{"Line":3},"fn_name":null},{"line":210,"address":[507125],"length":1,"stats":{"Line":3},"fn_name":null},{"line":214,"address":[506391],"length":1,"stats":{"Line":3},"fn_name":null},{"line":217,"address":[524976,524986],"length":1,"stats":{"Line":10},"fn_name":"{closure#0}"},{"line":220,"address":[506563,506467],"length":1,"stats":{"Line":8},"fn_name":null},{"line":221,"address":[506683,506573],"length":1,"stats":{"Line":4},"fn_name":null},{"line":222,"address":[506706,506666,506760],"length":1,"stats":{"Line":8},"fn_name":null},{"line":224,"address":[506773,506731],"length":1,"stats":{"Line":10},"fn_name":null},{"line":225,"address":[506837,506791,506885],"length":1,"stats":{"Line":10},"fn_name":null},{"line":226,"address":[506908,506856,507040],"length":1,"stats":{"Line":10},"fn_name":null},{"line":227,"address":[506931],"length":1,"stats":{"Line":5},"fn_name":null},{"line":228,"address":[507024],"length":1,"stats":{"Line":1},"fn_name":null},{"line":232,"address":[506538],"length":1,"stats":{"Line":1},"fn_name":null},{"line":256,"address":[506128],"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[506133],"length":1,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[506156],"length":1,"stats":{"Line":1},"fn_name":null},{"line":279,"address":[507472],"length":1,"stats":{"Line":2},"fn_name":null},{"line":280,"address":[507477],"length":1,"stats":{"Line":2},"fn_name":null},{"line":294,"address":[508192],"length":1,"stats":{"Line":1},"fn_name":null},{"line":295,"address":[508197],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":57,"coverable":57},{"path":["/","home","kingingwang","workspace","rust","battery-estimator","src","error.rs"],"content":"//! Error types for battery SOC estimation\n//!\n//! This module defines the error types that can occur during battery\n//! state-of-charge estimation operations.\n\nuse thiserror::Error;\n\n/// Errors that can occur during battery SOC estimation\n///\n/// This enum represents all possible error conditions that may arise\n/// when using the battery estimator library.\n///\n/// # Examples\n///\n/// ```no_run\n/// use battery_estimator::{BatteryChemistry, SocEstimator, Error};\n///\n/// let estimator = SocEstimator::new(BatteryChemistry::LiPo);\n///\n/// match estimator.estimate_soc(3.7) {\n///     Ok(soc) =\u003e println!(\"SOC: {:.1}%\", soc),\n///     Err(Error::InvalidCurve) =\u003e eprintln!(\"Invalid battery curve\"),\n///     Err(Error::NumericalError) =\u003e eprintln!(\"Calculation error\"),\n///     Err(Error::InvalidTemperature) =\u003e eprintln!(\"Invalid temperature\"),\n/// }\n/// ```\n#[derive(Error, Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub enum Error {\n    /// The voltage curve data is invalid\n    ///\n    /// This error occurs when:\n    /// - The curve has fewer than 2 points (cannot interpolate)\n    /// - The curve points are not properly ordered\n    /// - The curve has duplicate voltage values\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use battery_estimator::{Curve, CurvePoint, Error};\n    ///\n    /// // Invalid: Only one point\n    /// let invalid_curve = Curve::new(\u0026[CurvePoint::new(3.7, 50.0)]);\n    /// let result = invalid_curve.voltage_to_soc(3.7);\n    /// assert!(matches!(result, Err(Error::InvalidCurve)));\n    /// ```\n    #[error(\"Invalid voltage curve\")]\n    InvalidCurve,\n\n    /// A numerical error occurred during calculation\n    ///\n    /// This error occurs when:\n    /// - Division by zero in interpolation\n    /// - Overflow or underflow in calculations\n    /// - Invalid floating-point operations\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use battery_estimator::{Curve, CurvePoint, Error};\n    ///\n    /// // This could occur if curve points have the same voltage\n    /// let problematic_curve = Curve::new(\u0026[\n    ///     CurvePoint::new(3.7, 50.0),\n    ///     CurvePoint::new(3.7, 60.0), // Duplicate voltage!\n    /// ]);\n    /// ```\n    #[error(\"Numerical error in calculation\")]\n    NumericalError,\n\n    /// The temperature value is invalid\n    ///\n    /// This error occurs when:\n    /// - Temperature is NaN (Not a Number)\n    /// - Temperature is infinity\n    /// - Temperature is outside reasonable bounds\n    ///\n    /// # Examples\n    ///\n    /// ```no_run\n    /// use battery_estimator::{BatteryChemistry, SocEstimator, Error};\n    ///\n    /// let estimator = SocEstimator::new(BatteryChemistry::LiPo);\n    ///\n    /// // Invalid temperature\n    /// let result = estimator.estimate_soc_with_temp(3.7, f32::NAN);\n    /// ```\n    #[error(\"Invalid temperature\")]\n    InvalidTemperature,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use core::fmt::Write;\n\n    #[test]\n    fn test_error_display() {\n        // In no-std, Display is available via core::fmt\n        // We can test that the Display implementation compiles and works\n        let mut buffer = [0u8; 64];\n\n        // Test InvalidCurve\n        let mut writer = BufferWriter::new(\u0026mut buffer);\n        write!(writer, \"{}\", Error::InvalidCurve).unwrap();\n        assert_eq!(writer.as_str(), \"Invalid voltage curve\");\n\n        // Test NumericalError\n        let mut writer = BufferWriter::new(\u0026mut buffer);\n        write!(writer, \"{}\", Error::NumericalError).unwrap();\n        assert_eq!(writer.as_str(), \"Numerical error in calculation\");\n\n        // Test InvalidTemperature\n        let mut writer = BufferWriter::new(\u0026mut buffer);\n        write!(writer, \"{}\", Error::InvalidTemperature).unwrap();\n        assert_eq!(writer.as_str(), \"Invalid temperature\");\n    }\n\n    #[test]\n    fn test_error_equality() {\n        assert_eq!(Error::InvalidCurve, Error::InvalidCurve);\n        assert_eq!(Error::NumericalError, Error::NumericalError);\n        assert_eq!(Error::InvalidTemperature, Error::InvalidTemperature);\n\n        assert_ne!(Error::InvalidCurve, Error::NumericalError);\n    }\n\n    #[test]\n    fn test_error_copy() {\n        let error1 = Error::InvalidCurve;\n        let error2 = error1;\n        assert_eq!(error1, error2);\n    }\n\n    #[test]\n    fn test_error_debug() {\n        let error = Error::NumericalError;\n        let mut buffer = [0u8; 64];\n        let mut writer = BufferWriter::new(\u0026mut buffer);\n        write!(writer, \"{:?}\", error).unwrap();\n        assert!(writer.as_str().contains(\"NumericalError\"));\n    }\n\n    #[test]\n    fn test_error_all_variants() {\n        // Test that all error variants can be created\n        let errors = [\n            Error::InvalidCurve,\n            Error::NumericalError,\n            Error::InvalidTemperature,\n        ];\n        assert_eq!(errors.len(), 3);\n    }\n\n    #[test]\n    fn test_error_variants_distinct() {\n        let error1 = Error::InvalidCurve;\n        let error2 = Error::NumericalError;\n        let error3 = Error::InvalidTemperature;\n\n        // Verify all variants are distinct\n        assert_ne!(error1, error2);\n        assert_ne!(error2, error3);\n        assert_ne!(error1, error3);\n    }\n\n    // Helper struct for testing Display in no-std\n    struct BufferWriter\u003c'a\u003e {\n        buffer: \u0026'a mut [u8],\n        pos: usize,\n    }\n\n    impl\u003c'a\u003e BufferWriter\u003c'a\u003e {\n        fn new(buffer: \u0026'a mut [u8]) -\u003e Self {\n            BufferWriter { buffer, pos: 0 }\n        }\n\n        fn as_str(\u0026self) -\u003e \u0026str {\n            core::str::from_utf8(\u0026self.buffer[..self.pos]).unwrap()\n        }\n    }\n\n    impl\u003c'a\u003e core::fmt::Write for BufferWriter\u003c'a\u003e {\n        fn write_str(\u0026mut self, s: \u0026str) -\u003e core::fmt::Result {\n            let bytes = s.as_bytes();\n            if self.pos + bytes.len() \u003e self.buffer.len() {\n                return Err(core::fmt::Error);\n            }\n            self.buffer[self.pos..self.pos + bytes.len()].copy_from_slice(bytes);\n            self.pos += bytes.len();\n            Ok(())\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kingingwang","workspace","rust","battery-estimator","src","estimator.rs"],"content":"//! SOC (State of Charge) Estimator with Temperature Compensation\n\nuse crate::{\n    compensate_aging, compensate_temperature, default_curves, default_temperature_compensation,\n    BatteryChemistry, Curve, Error,\n};\n\n/// SOC estimator configuration\n#[repr(C)]\n#[derive(Debug, Clone, Copy)]\npub struct EstimatorConfig {\n    /// Nominal temperature (°C)\n    pub nominal_temperature: f32,\n    /// Temperature compensation coefficient (percentage change per °C)\n    pub temperature_coefficient: f32,\n    /// Battery age (years)\n    pub age_years: f32,\n    /// Aging factor (capacity loss percentage per year)\n    pub aging_factor: f32,\n    /// Compensation flags (bit field compression)\n    flags: u8,\n}\n\nimpl EstimatorConfig {\n    /// Default configuration\n    #[inline]\n    pub const fn default() -\u003e Self {\n        Self {\n            nominal_temperature: 25.0,\n            temperature_coefficient: 0.005, // 0.5% per °C (matches default_temperature_compensation)\n            age_years: 0.0,\n            aging_factor: 0.02, // 2% capacity loss per year\n            flags: 0,\n        }\n    }\n\n    /// Enable temperature compensation\n    #[inline]\n    pub const fn with_temperature_compensation(mut self) -\u003e Self {\n        self.flags |= 0x01;\n        self\n    }\n\n    /// Enable aging compensation\n    #[inline]\n    pub const fn with_aging_compensation(mut self) -\u003e Self {\n        self.flags |= 0x02;\n        self\n    }\n\n    /// Set nominal temperature\n    #[inline]\n    pub const fn with_nominal_temperature(mut self, temp: f32) -\u003e Self {\n        self.nominal_temperature = temp;\n        self\n    }\n\n    /// Set temperature coefficient\n    #[inline]\n    pub const fn with_temperature_coefficient(mut self, coeff: f32) -\u003e Self {\n        self.temperature_coefficient = coeff;\n        self\n    }\n\n    /// Set battery age\n    #[inline]\n    pub const fn with_age_years(mut self, years: f32) -\u003e Self {\n        self.age_years = years;\n        self\n    }\n\n    /// Set aging factor\n    #[inline]\n    pub const fn with_aging_factor(mut self, factor: f32) -\u003e Self {\n        self.aging_factor = factor;\n        self\n    }\n\n    /// Returns `true` if temperature compensation is enabled\n    pub const fn is_temperature_compensation_enabled(self) -\u003e bool {\n        (self.flags \u0026 0x01) != 0\n    }\n\n    /// Returns `true` if aging compensation is enabled\n    pub const fn is_aging_compensation_enabled(self) -\u003e bool {\n        (self.flags \u0026 0x02) != 0\n    }\n}\n\n// Non-const Default implementation\nimpl Default for EstimatorConfig {\n    #[inline]\n    fn default() -\u003e Self {\n        Self::default()\n    }\n}\n\n/// SOC estimator\n#[derive(Debug, Clone, Copy)]\npub struct SocEstimator {\n    curve: \u0026'static Curve,\n    config: EstimatorConfig,\n}\n\nimpl SocEstimator {\n    /// Create a new SOC estimator (default configuration)\n    pub const fn new(chemistry: BatteryChemistry) -\u003e Self {\n        let curve = match chemistry {\n            BatteryChemistry::LiPo =\u003e \u0026default_curves::LIPO,\n            BatteryChemistry::LiFePO4 =\u003e \u0026default_curves::LIFEPO4,\n            BatteryChemistry::LiIon =\u003e \u0026default_curves::LIION,\n            BatteryChemistry::Lipo410Full340Cutoff =\u003e \u0026default_curves::LIPO410_FULL340_CUTOFF,\n        };\n\n        Self {\n            curve,\n            config: EstimatorConfig::default(), // This is now a const function\n        }\n    }\n\n    /// Create estimator with custom curve\n    pub const fn with_custom_curve(curve: \u0026'static Curve) -\u003e Self {\n        Self {\n            curve,\n            config: EstimatorConfig::default(),\n        }\n    }\n\n    /// Create estimator with configuration (const version)\n    pub const fn with_config(chemistry: BatteryChemistry, config: EstimatorConfig) -\u003e Self {\n        let curve = match chemistry {\n            BatteryChemistry::LiPo =\u003e \u0026default_curves::LIPO,\n            BatteryChemistry::LiFePO4 =\u003e \u0026default_curves::LIFEPO4,\n            BatteryChemistry::LiIon =\u003e \u0026default_curves::LIION,\n            BatteryChemistry::Lipo410Full340Cutoff =\u003e \u0026default_curves::LIPO410_FULL340_CUTOFF,\n        };\n\n        Self { curve, config }\n    }\n\n    /// Estimate SOC (without temperature compensation)\n    pub fn estimate_soc(\u0026self, voltage: f32) -\u003e Result\u003cf32, Error\u003e {\n        self.curve.voltage_to_soc(voltage)\n    }\n\n    /// Estimate SOC with default temperature compensation (ignores configuration)\n    ///\n    /// This method always applies temperature compensation using default parameters\n    /// (nominal temperature: 25°C, coefficient: 0.005), regardless of the estimator's\n    /// current configuration. For configuration-based compensation, use\n    /// `estimate_soc_compensated()` instead.\n    ///\n    /// # Arguments\n    ///\n    /// * `voltage` - Battery voltage in volts\n    /// * `temperature` - Current battery temperature in Celsius\n    ///\n    /// # Returns\n    ///\n    /// Temperature-compensated SOC percentage using default parameters\n    pub fn estimate_soc_with_temp(\u0026self, voltage: f32, temperature: f32) -\u003e Result\u003cf32, Error\u003e {\n        let base_soc = self.curve.voltage_to_soc(voltage)?;\n\n        // Always apply temperature compensation with default parameters\n        let compensated = default_temperature_compensation(base_soc, temperature);\n\n        Ok(compensated.clamp(0.0, 100.0))\n    }\n\n    /// Estimate SOC (using configuration settings)\n    pub fn estimate_soc_compensated(\u0026self, voltage: f32, temperature: f32) -\u003e Result\u003cf32, Error\u003e {\n        let base_soc = self.curve.voltage_to_soc(voltage)?;\n        let mut soc = base_soc;\n\n        // Apply temperature compensation\n        if EstimatorConfig::is_temperature_compensation_enabled(self.config) {\n            soc = compensate_temperature(\n                soc,\n                temperature,\n                self.config.nominal_temperature,\n                self.config.temperature_coefficient,\n            );\n        }\n\n        // Apply aging compensation\n        if EstimatorConfig::is_aging_compensation_enabled(self.config) {\n            soc = compensate_aging(soc, self.config.age_years, self.config.aging_factor);\n        }\n\n        // Ensure SOC is within valid range\n        Ok(soc.clamp(0.0, 100.0))\n    }\n\n    /// Get voltage range\n    pub const fn voltage_range(\u0026self) -\u003e (f32, f32) {\n        self.curve.voltage_range()\n    }\n\n    /// Update configuration\n    #[inline]\n    pub fn update_config(\u0026mut self, config: EstimatorConfig) {\n        self.config = config;\n    }\n\n    /// Get current configuration\n    #[inline]\n    pub const fn config(\u0026self) -\u003e \u0026EstimatorConfig {\n        \u0026self.config\n    }\n\n    /// Enable temperature compensation\n    pub fn enable_temperature_compensation(\u0026mut self, nominal_temp: f32, coefficient: f32) {\n        self.config = self\n            .config\n            .with_temperature_compensation()\n            .with_nominal_temperature(nominal_temp)\n            .with_temperature_coefficient(coefficient);\n    }\n\n    /// Enable aging compensation\n    pub fn enable_aging_compensation(\u0026mut self, age_years: f32, aging_factor: f32) {\n        self.config = self\n            .config\n            .with_aging_compensation()\n            .with_age_years(age_years)\n            .with_aging_factor(aging_factor);\n    }\n\n    /// Disable all compensation\n    pub fn disable_all_compensation(\u0026mut self) {\n        self.config = EstimatorConfig::default();\n    }\n}\n\n// Convenience constructors for simplified usage\nimpl SocEstimator {\n    /// Create estimator with temperature compensation\n    #[inline]\n    pub fn with_temperature_compensation(\n        chemistry: BatteryChemistry,\n        nominal_temp: f32,\n        coefficient: f32,\n    ) -\u003e Self {\n        let config = EstimatorConfig::default()\n            .with_temperature_compensation()\n            .with_nominal_temperature(nominal_temp)\n            .with_temperature_coefficient(coefficient);\n\n        Self::with_config(chemistry, config)\n    }\n\n    /// Create estimator with aging compensation\n    #[inline]\n    pub fn with_aging_compensation(\n        chemistry: BatteryChemistry,\n        age_years: f32,\n        aging_factor: f32,\n    ) -\u003e Self {\n        let config = EstimatorConfig::default()\n            .with_aging_compensation()\n            .with_age_years(age_years)\n            .with_aging_factor(aging_factor);\n\n        Self::with_config(chemistry, config)\n    }\n\n    /// Create estimator with all compensation enabled\n    #[inline]\n    pub fn with_all_compensation(\n        chemistry: BatteryChemistry,\n        nominal_temp: f32,\n        temp_coeff: f32,\n        age_years: f32,\n        aging_factor: f32,\n    ) -\u003e Self {\n        let config = EstimatorConfig::default()\n            .with_temperature_compensation()\n            .with_aging_compensation()\n            .with_nominal_temperature(nominal_temp)\n            .with_temperature_coefficient(temp_coeff)\n            .with_age_years(age_years)\n            .with_aging_factor(aging_factor);\n\n        Self::with_config(chemistry, config)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_estimator_basic() {\n        let estimator = SocEstimator::new(BatteryChemistry::LiPo);\n\n        // Test boundaries\n        assert!(estimator.estimate_soc(3.2).unwrap().abs() \u003c 1.0);\n        assert!(estimator.estimate_soc(4.2).unwrap() \u003e 99.0);\n\n        // Test typical values\n        let soc = estimator.estimate_soc(3.7).unwrap();\n        assert!(\n            (45.0..=55.0).contains(\u0026soc),\n            \"3.7V should be around 50%, got {}\",\n            soc\n        );\n    }\n\n    #[test]\n    fn test_estimator_with_temp() {\n        let estimator = SocEstimator::new(BatteryChemistry::LiPo);\n\n        // Test different temperatures\n        let base_soc = estimator.estimate_soc(3.7).unwrap();\n        let cold_soc = estimator.estimate_soc_with_temp(3.7, 0.0).unwrap();\n        let hot_soc = estimator.estimate_soc_with_temp(3.7, 50.0).unwrap();\n\n        // Low temperature should show LOWER SOC (reduced capacity due to higher internal resistance)\n        assert!(\n            cold_soc \u003c base_soc,\n            \"Cold temp should decrease SOC due to reduced capacity\"\n        );\n        // High temperature should show slightly higher SOC (better efficiency)\n        assert!(\n            hot_soc \u003e= base_soc,\n            \"Hot temp should maintain or slightly increase SOC\"\n        );\n    }\n\n    #[test]\n    fn test_estimator_custom_curve() {\n        use crate::CurvePoint;\n        const CUSTOM_CURVE: Curve = Curve::new(\u0026[\n            CurvePoint::new(3.0, 0.0),\n            CurvePoint::new(3.5, 50.0),\n            CurvePoint::new(4.0, 100.0),\n        ]);\n\n        let estimator = SocEstimator::with_custom_curve(\u0026CUSTOM_CURVE);\n\n        assert_eq!(estimator.estimate_soc(3.0).unwrap(), 0.0);\n        assert_eq!(estimator.estimate_soc(3.5).unwrap(), 50.0);\n        assert_eq!(estimator.estimate_soc(4.0).unwrap(), 100.0);\n    }\n    #[test]\n    fn test_estimator_all_battery_types() {\n        // Test all battery chemistries\n        let lipo = SocEstimator::new(BatteryChemistry::LiPo);\n        let lifepo4 = SocEstimator::new(BatteryChemistry::LiFePO4);\n        let _lilon = SocEstimator::new(BatteryChemistry::LiIon);\n        let conservative = SocEstimator::new(BatteryChemistry::Lipo410Full340Cutoff);\n\n        // All should produce valid SOC values\n        assert!(lipo.estimate_soc(3.7).is_ok());\n        assert!(lifepo4.estimate_soc(3.2).is_ok());\n        assert!(_lilon.estimate_soc(3.7).is_ok());\n        assert!(conservative.estimate_soc(3.77).is_ok());\n    }\n    #[test]\n    fn test_estimator_voltage_range() {\n        let estimator = SocEstimator::new(BatteryChemistry::LiPo);\n        let (min, max) = estimator.voltage_range();\n\n        assert_eq!(min, 3.2);\n        assert_eq!(max, 4.2);\n    }\n\n    #[test]\n    fn test_estimator_estimate_soc_compensated() {\n        let config = EstimatorConfig::default()\n            .with_temperature_compensation()\n            .with_aging_compensation()\n            .with_age_years(1.0)\n            .with_aging_factor(0.02);\n\n        let estimator = SocEstimator::with_config(BatteryChemistry::LiPo, config);\n\n        // Test with both compensations enabled\n        let soc = estimator.estimate_soc_compensated(3.7, 25.0).unwrap();\n        assert!(soc \u003e 0.0 \u0026\u0026 soc \u003c 100.0);\n\n        // Cold temperature should reduce SOC\n        let cold_soc = estimator.estimate_soc_compensated(3.7, 0.0).unwrap();\n        assert!(cold_soc \u003c soc);\n    }\n\n    #[test]\n    fn test_estimator_update_config() {\n        let mut estimator = SocEstimator::new(BatteryChemistry::LiPo);\n\n        let new_config = EstimatorConfig::default()\n            .with_temperature_compensation()\n            .with_nominal_temperature(30.0);\n\n        estimator.update_config(new_config);\n        assert!(estimator.config().is_temperature_compensation_enabled());\n        assert_eq!(estimator.config().nominal_temperature, 30.0);\n    }\n\n    #[test]\n    fn test_estimator_with_all_compensation() {\n        let estimator =\n            SocEstimator::with_all_compensation(BatteryChemistry::LiPo, 25.0, 0.005, 2.0, 0.02);\n\n        let config = estimator.config();\n        assert!(config.is_temperature_compensation_enabled());\n        assert!(config.is_aging_compensation_enabled());\n        assert_eq!(config.nominal_temperature, 25.0);\n        assert_eq!(config.temperature_coefficient, 0.005);\n        assert_eq!(config.age_years, 2.0);\n        assert_eq!(config.aging_factor, 0.02);\n    }\n\n    #[test]\n    fn test_estimator_with_config_lipo410() {\n        // Test with_config using Lipo410Full340Cutoff to cover line 137\n        let config = EstimatorConfig::default()\n            .with_temperature_compensation()\n            .with_nominal_temperature(25.0);\n\n        let estimator = SocEstimator::with_config(BatteryChemistry::Lipo410Full340Cutoff, config);\n\n        // Verify the curve is correct\n        let (min, max) = estimator.voltage_range();\n        assert_eq!(min, 3.4);\n        assert_eq!(max, 4.1);\n\n        // Test SOC estimation\n        let soc = estimator.estimate_soc(3.77).unwrap();\n        assert!((soc - 50.0).abs() \u003c 1.0);\n    }\n\n    #[test]\n    fn test_estimate_soc_compensated_with_temp_only() {\n        // Test temperature compensation in estimate_soc_compensated\n        let config = EstimatorConfig::default()\n            .with_temperature_compensation()\n            .with_nominal_temperature(25.0)\n            .with_temperature_coefficient(0.005); // 0.5% per °C\n\n        let estimator = SocEstimator::with_config(BatteryChemistry::LiPo, config);\n\n        // At cold temperature (0°C), SOC should appear LOWER (reduced capacity)\n        let soc_cold = estimator.estimate_soc_compensated(3.7, 0.0).unwrap();\n        let soc_normal = estimator.estimate_soc_compensated(3.7, 25.0).unwrap();\n\n        assert!(\n            soc_cold \u003c soc_normal,\n            \"Cold temperature should decrease SOC due to reduced capacity\"\n        );\n    }\n\n    #[test]\n    fn test_estimator_disable_all_compensation() {\n        let mut estimator =\n            SocEstimator::with_all_compensation(BatteryChemistry::LiPo, 25.0, 0.0005, 2.0, 0.02);\n\n        estimator.disable_all_compensation();\n\n        assert!(!estimator.config().is_temperature_compensation_enabled());\n        assert!(!estimator.config().is_aging_compensation_enabled());\n    }\n\n    #[test]\n    fn test_estimator_enable_methods() {\n        // Test enable_temperature_compensation method (lines 212-217)\n        let mut estimator = SocEstimator::new(BatteryChemistry::LiPo);\n        estimator.enable_temperature_compensation(30.0, 0.006);\n        assert!(estimator.config().is_temperature_compensation_enabled());\n        assert_eq!(estimator.config().nominal_temperature, 30.0);\n        assert_eq!(estimator.config().temperature_coefficient, 0.006);\n\n        // Test enable_aging_compensation method (lines 221-226)\n        estimator.enable_aging_compensation(3.0, 0.03);\n        assert!(estimator.config().is_aging_compensation_enabled());\n        assert_eq!(estimator.config().age_years, 3.0);\n        assert_eq!(estimator.config().aging_factor, 0.03);\n    }\n\n    #[test]\n    fn test_estimator_convenience_constructors() {\n        // Test with_temperature_compensation (lines 239-249)\n        let estimator1 =\n            SocEstimator::with_temperature_compensation(BatteryChemistry::LiPo, 30.0, 0.006);\n        assert!(estimator1.config().is_temperature_compensation_enabled());\n        assert_eq!(estimator1.config().nominal_temperature, 30.0);\n        assert_eq!(estimator1.config().temperature_coefficient, 0.006);\n\n        // Test with_aging_compensation (lines 254-264)\n        let estimator2 =\n            SocEstimator::with_aging_compensation(BatteryChemistry::LiFePO4, 2.0, 0.025);\n        assert!(estimator2.config().is_aging_compensation_enabled());\n        assert_eq!(estimator2.config().age_years, 2.0);\n        assert_eq!(estimator2.config().aging_factor, 0.025);\n\n        // Test with_config for all battery chemistries including LiIon (line 134)\n        let lilon_config = EstimatorConfig::default();\n        let lilon_estimator = SocEstimator::with_config(BatteryChemistry::LiIon, lilon_config);\n        let (min, max) = lilon_estimator.voltage_range();\n        assert_eq!(min, 2.5); // LiIon min voltage is 2.5V\n        assert_eq!(max, 4.2);\n\n        // Test Default trait for EstimatorConfig (lines 93-94)\n        let default_config: EstimatorConfig = Default::default();\n        assert_eq!(default_config.nominal_temperature, 25.0);\n        assert_eq!(default_config.temperature_coefficient, 0.005);\n    }\n\n    #[test]\n    fn test_estimate_soc_with_temp_clamping() {\n        let estimator = SocEstimator::new(BatteryChemistry::LiPo);\n\n        // Test that temperature compensation is clamped to valid range\n        let result = estimator.estimate_soc_with_temp(3.7, -100.0);\n        assert!(result.is_ok());\n\n        let soc = result.unwrap();\n        assert!((0.0..=100.0).contains(\u0026soc));\n    }\n\n    #[test]\n    fn test_estimator_copy() {\n        let estimator1 = SocEstimator::new(BatteryChemistry::LiPo);\n        let estimator2 = estimator1;\n\n        // Both should work independently\n        assert!(estimator1.estimate_soc(3.7).is_ok());\n        assert!(estimator2.estimate_soc(3.7).is_ok());\n    }\n\n    #[test]\n    fn test_estimator_extreme_temperatures() {\n        let estimator = SocEstimator::new(BatteryChemistry::LiPo);\n\n        // Test extreme cold\n        let cold_result = estimator.estimate_soc_with_temp(3.7, -40.0);\n        assert!(cold_result.is_ok());\n\n        // Test extreme heat\n        let hot_result = estimator.estimate_soc_with_temp(3.7, 80.0);\n        assert!(hot_result.is_ok());\n\n        // Results should be clamped to valid range\n        assert!(cold_result.unwrap() \u003e= 0.0 \u0026\u0026 cold_result.unwrap() \u003c= 100.0);\n        assert!(hot_result.unwrap() \u003e= 0.0 \u0026\u0026 hot_result.unwrap() \u003c= 100.0);\n    }\n}\n","traces":[{"line":27,"address":[456672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[456608],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[456611],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[456620],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[456448],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[456451],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[456460],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[456496],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[456505],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[456509],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[456560],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[456569],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[456574],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[456352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[456361],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[456366],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[456400],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[456409],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[456414],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[456656],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[456544],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[457296],"length":1,"stats":{"Line":1},"fn_name":"default"},{"line":94,"address":[457304],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[456160],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[456181],"length":1,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[456212],"length":1,"stats":{"Line":3},"fn_name":null},{"line":110,"address":[456226],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[456240],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[456254],"length":1,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[456276],"length":1,"stats":{"Line":3},"fn_name":null},{"line":122,"address":[454368],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[454391],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[454112],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[454134],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[454165],"length":1,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[454179],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[454193],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[454207],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[454272],"length":1,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[454287],"length":1,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[454768],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[454795],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[454928],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[454939],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[455248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[455282],"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[455422],"length":1,"stats":{"Line":2},"fn_name":null},{"line":176,"address":[455428,455549],"length":1,"stats":{"Line":3},"fn_name":null},{"line":177,"address":[455538],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[455522],"length":1,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[455528],"length":1,"stats":{"Line":2},"fn_name":null},{"line":181,"address":[455533],"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[455471,455617],"length":1,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[455590],"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[455551],"length":1,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[454352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[454357],"length":1,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[454320],"length":1,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[454325],"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[456336],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[456344],"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[456000],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[456125,456038],"length":1,"stats":{"Line":2},"fn_name":null},{"line":215,"address":[456063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[456084],"length":1,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[456105],"length":1,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[455632],"length":1,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[455757,455670],"length":1,"stats":{"Line":2},"fn_name":null},{"line":224,"address":[455695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[455716],"length":1,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[455737],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[455184],"length":1,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[455197],"length":1,"stats":{"Line":1},"fn_name":null},{"line":239,"address":[455792],"length":1,"stats":{"Line":1},"fn_name":null},{"line":244,"address":[455847],"length":1,"stats":{"Line":1},"fn_name":null},{"line":246,"address":[455878],"length":1,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[455899],"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[455923],"length":1,"stats":{"Line":1},"fn_name":null},{"line":254,"address":[454976],"length":1,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[455031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[455062],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[455083],"length":1,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[455107],"length":1,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[454448],"length":1,"stats":{"Line":1},"fn_name":null},{"line":276,"address":[454539],"length":1,"stats":{"Line":1},"fn_name":null},{"line":279,"address":[454600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":280,"address":[454624],"length":1,"stats":{"Line":1},"fn_name":null},{"line":281,"address":[454645],"length":1,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[454666],"length":1,"stats":{"Line":1},"fn_name":null},{"line":284,"address":[454690],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":90,"coverable":90},{"path":["/","home","kingingwang","workspace","rust","battery-estimator","src","lib.rs"],"content":"//! # Battery SOC (State of Charge) Estimator\n//!\n//! A lightweight, zero-dependency, `no_std` compatible Rust library for estimating\n//! battery state-of-charge (SOC) from voltage measurements. Designed specifically\n//! for embedded systems and microcontrollers.\n//!\n//! ## Features\n//!\n//! - **Minimal dependencies** - Only depends on `thiserror` for error handling\n//! - **`no_std` compatible** - Works in embedded environments\n//! - **No heap allocations** - Uses only stack memory and fixed-size arrays\n//! - **Multiple battery chemistries** - Built-in support for LiPo, LiFePO4, Li-Ion\n//! - **Temperature compensation** - Correct SOC readings based on temperature\n//! - **Aging compensation** - Adjust for battery capacity degradation over time\n//! - **Custom voltage curves** - Define your own voltage-SOC relationships\n//! - **Conservative battery curves** - Extended battery life with conservative thresholds\n//!\n//! ## Quick Start\n//!\n//! ```rust\n//! use battery_estimator::{BatteryChemistry, SocEstimator};\n//!\n//! // Create estimator for a standard LiPo battery\n//! let estimator = SocEstimator::new(BatteryChemistry::LiPo);\n//!\n//! // Estimate SOC at 3.7V (nominal voltage)\n//! match estimator.estimate_soc(3.7) {\n//!     Ok(soc) =\u003e println!(\"Battery SOC: {:.1}%\", soc),\n//!     Err(e) =\u003e println!(\"Error estimating SOC: {}\", e),\n//! }\n//! ```\n//!\n//! ## Battery Types\n//!\n//! The library supports multiple battery chemistries with built-in voltage curves:\n//!\n//! | Type | Full Charge | Cutoff | Description |\n//! |------|-------------|--------|-------------|\n//! | `LiPo` | 4.2V | 3.2V | Standard Lithium Polymer |\n//! | `LiFePO4` | 3.65V | 3.0V | Lithium Iron Phosphate (long cycle life) |\n//! | `LiIon` | 4.2V | 3.3V | Standard Lithium Ion |\n//! | `Lipo410Full340Cutoff` | 4.1V | 3.4V | Conservative LiPo (extended life) |\n//!\n//! ## Temperature Compensation\n//!\n//! ```rust\n//! use battery_estimator::{BatteryChemistry, SocEstimator};\n//!\n//! // Create estimator with temperature compensation\n//! let estimator = SocEstimator::with_temperature_compensation(\n//!     BatteryChemistry::LiPo,\n//!     25.0,  // Nominal temperature (°C)\n//!     0.0005 // Temperature coefficient\n//! );\n//!\n//! // Estimate SOC with current temperature\n//! match estimator.estimate_soc_compensated(3.7, 20.0) {\n//!     Ok(soc) =\u003e println!(\"Temperature-compensated SOC: {:.1}%\", soc),\n//!     Err(e) =\u003e println!(\"Error: {}\", e),\n//! }\n//! ```\n//!\n//! ## Custom Voltage Curves\n//!\n//! ```rust\n//! use battery_estimator::{SocEstimator, Curve, CurvePoint};\n//!\n//! // Define a custom voltage-SOC curve\n//! const CUSTOM_CURVE: Curve = Curve::new(\u0026[\n//!     CurvePoint::new(3.0, 0.0),   // 3.0V = 0%\n//!     CurvePoint::new(3.5, 50.0),  // 3.5V = 50%\n//!     CurvePoint::new(4.0, 100.0), // 4.0V = 100%\n//! ]);\n//!\n//! // Create estimator with custom curve\n//! let estimator = SocEstimator::with_custom_curve(\u0026CUSTOM_CURVE);\n//! ```\n//! ## Module Structure\n//!\n//! - [`SocEstimator`] - Main estimator struct for SOC calculations\n//! - [`EstimatorConfig`] - Configuration for SOC estimator (compensation settings)\n//! - [`BatteryChemistry`] - Supported battery types\n//! - [`Curve`] - Voltage-SOC curve representation\n//! - [`CurvePoint`] - Individual voltage-SOC data point\n//! - [`Error`] - Error types for estimation failures\n//! - [`compensate_temperature`] - Temperature compensation function\n//! - [`compensate_aging`] - Aging compensation function\n\n#![no_std]\n#![deny(missing_docs, unsafe_code)]\n\nmod compensation;\nmod curve;\nmod error;\nmod estimator;\nmod types;\n\npub use compensation::{\n    compensate_aging, compensate_temperature, default_temperature_compensation,\n};\npub use curve::{default_curves, Curve};\npub use error::Error;\npub use estimator::{EstimatorConfig, SocEstimator};\npub use types::{BatteryChemistry, CurvePoint};\n\n/// Prelude module for convenient imports\n///\n/// This module re-exports the most commonly used types and traits,\n/// allowing you to import them with a single `use` statement:\n///\n/// ```rust\n/// use battery_estimator::prelude::*;\n///\n/// let estimator = SocEstimator::new(BatteryChemistry::LiPo);\n/// ```\npub mod prelude {\n    pub use crate::{BatteryChemistry, CurvePoint, Error, SocEstimator};\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","kingingwang","workspace","rust","battery-estimator","src","types.rs"],"content":"//! Type definitions for battery SOC estimation\n//!\n//! This module contains the core data types used throughout the library:\n//!\n//! - [`BatteryChemistry`] - Enumeration of supported battery types\n//! - [`CurvePoint`] - Individual voltage-SOC data point for curves\n\n/// Const-compatible check for finite f32 values\n///\n/// Returns true if the value is neither NaN nor infinite.\n#[inline]\nconst fn is_finite_const(value: f32) -\u003e bool {\n    // A value is finite if it's not NaN and not infinite\n    // NaN: exponent all 1s, mantissa non-zero\n    // Infinity: exponent all 1s, mantissa zero\n    // We check if exponent bits are not all 1s (0xFF)\n    let bits = value.to_bits();\n    let exponent = (bits \u003e\u003e 23) \u0026 0xFF;\n    exponent != 0xFF\n}\n\n/// Battery chemistry types supported by the library\n///\n/// Each variant represents a specific battery chemistry with its own\n/// built-in voltage-to-SOC curve. These curves are optimized for typical\n/// discharge characteristics of each chemistry.\n///\n/// # Voltage Ranges\n///\n/// | Chemistry | Full Charge | Cutoff | Description |\n/// |-----------|-------------|--------|-------------|\n/// | `LiPo` | 4.2V | 3.2V | Standard Lithium Polymer |\n/// | `LiFePO4` | 3.65V | 3.0V | Lithium Iron Phosphate (long cycle life) |\n/// | `LiIon` | 4.2V | 3.3V | Standard Lithium Ion |\n/// | `Lipo410Full340Cutoff` | 4.1V | 3.4V | Conservative LiPo (extended life) |\n///\n/// # Examples\n///\n/// ```\n/// use battery_estimator::{BatteryChemistry, SocEstimator};\n///\n/// // Create estimator for LiPo battery\n/// let estimator = SocEstimator::new(BatteryChemistry::LiPo);\n///\n/// // Create estimator for LiFePO4 battery\n/// let lfp_estimator = SocEstimator::new(BatteryChemistry::LiFePO4);\n/// ```\n///\n/// # Conservative Battery Curve\n///\n/// The `Lipo410Full340Cutoff` variant uses conservative thresholds:\n/// - **Lower full charge** (4.1V vs 4.2V) - Reduces stress on battery\n/// - **Higher cutoff** (3.4V vs 3.2V) - Prevents deep discharge\n/// - **Benefit**: Extended cycle life at cost of reduced capacity\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub enum BatteryChemistry {\n    /// Standard Lithium Polymer battery\n    ///\n    /// - Full charge: 4.2V\n    /// - Cutoff voltage: 3.2V\n    /// - Nominal voltage: 3.7V\n    /// - Typical use: RC vehicles, drones, portable electronics\n    LiPo,\n\n    /// Lithium Iron Phosphate (LiFePO4) battery\n    ///\n    /// - Full charge: 3.65V\n    /// - Cutoff voltage: 3.0V\n    /// - Nominal voltage: 3.2V\n    /// - Typical use: Solar systems, EVs, energy storage\n    /// - Advantages: Long cycle life (2000+ cycles), stable voltage\n    LiFePO4,\n\n    /// Standard Lithium Ion battery\n    ///\n    /// - Full charge: 4.2V\n    /// - Cutoff voltage: 3.3V\n    /// - Nominal voltage: 3.7V\n    /// - Typical use: Laptops, power tools, consumer electronics\n    LiIon,\n\n    /// Conservative LiPo battery curve for extended cycle life\n    ///\n    /// - Full charge: 4.1V (lower than standard 4.2V)\n    /// - Cutoff voltage: 3.4V (higher than standard 3.2V)\n    /// - Nominal voltage: 3.77V\n    /// - Use case: Applications prioritizing battery longevity over capacity\n    /// - Trade-off: ~15-20% less usable capacity for ~30% longer cycle life\n    Lipo410Full340Cutoff,\n}\n\n/// A single point on a voltage-SOC curve\n///\n/// This struct represents one data point in a battery discharge curve,\n/// mapping a specific voltage to a corresponding state-of-charge percentage.\n///\n/// # Internal Representation\n///\n/// For memory efficiency in embedded systems, values are stored as integers:\n/// - **Voltage**: Stored in millivolts (`u16`, range 0-65535 mV)\n/// - **SOC**: Stored in tenths of a percent (`u16`, range 0-1000 = 0-100%)\n///\n/// This representation reduces memory usage by 50% compared to `f32` storage\n/// while maintaining sufficient precision for battery estimation.\n///\n/// # Examples\n///\n/// ```\n/// use battery_estimator::CurvePoint;\n///\n/// // Create a curve point at 3.7V with 50% SOC\n/// let point = CurvePoint::new(3.7, 50.0);\n///\n/// // Access voltage in volts\n/// assert_eq!(point.voltage(), 3.7);\n///\n/// // Access SOC in percent\n/// assert_eq!(point.soc(), 50.0);\n///\n/// // Create from tuple\n/// let point2: CurvePoint = (3.8, 75.0).into();\n/// ```\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub struct CurvePoint {\n    /// Voltage in millivolts (mV)\n    ///\n    /// Range: 0-65535 mV (0-65.535V)\n    /// Internal storage format for memory efficiency\n    pub voltage_mv: u16,\n\n    /// State of charge in tenths of a percent\n    ///\n    /// Range: 0-1000 (0-100%)\n    /// Internal storage format for memory efficiency\n    pub soc_tenth: u16,\n}\n\nimpl CurvePoint {\n    /// Creates a new curve point from floating-point values\n    ///\n    /// # Arguments\n    ///\n    /// * `voltage` - Voltage in volts (e.g., 3.7). Must be non-negative and finite.\n    /// * `soc` - State of charge in percent (e.g., 50.0). Must be in range 0.0-100.0.\n    ///\n    /// # Input Handling\n    ///\n    /// - Negative voltages are clamped to 0.0\n    /// - NaN/Infinity voltages are treated as 0.0\n    /// - SOC values are clamped to 0.0-100.0 range\n    /// - NaN/Infinity SOC values are treated as 0.0\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use battery_estimator::CurvePoint;\n    ///\n    /// let point = CurvePoint::new(3.7, 50.0);\n    /// assert_eq!(point.voltage(), 3.7);\n    /// assert_eq!(point.soc(), 50.0);\n    ///\n    /// // Negative voltage is clamped to 0\n    /// let clamped = CurvePoint::new(-1.0, 50.0);\n    /// assert_eq!(clamped.voltage(), 0.0);\n    /// ```\n    #[inline]\n    pub const fn new(voltage: f32, soc: f32) -\u003e Self {\n        // Validate and clamp voltage (must be non-negative, max 65.535V for u16)\n        let safe_voltage = if voltage \u003c 0.0 || !is_finite_const(voltage) {\n            0.0\n        } else if voltage \u003e 65.535 {\n            65.535\n        } else {\n            voltage\n        };\n\n        // Validate and clamp SOC (must be 0-100%)\n        let safe_soc = if soc \u003c 0.0 || !is_finite_const(soc) {\n            0.0\n        } else if soc \u003e 100.0 {\n            100.0\n        } else {\n            soc\n        };\n\n        Self {\n            voltage_mv: (safe_voltage * 1000.0) as u16,\n            soc_tenth: (safe_soc * 10.0) as u16,\n        }\n    }\n\n    /// Creates a new curve point without validation (for performance-critical code)\n    ///\n    /// # Safety\n    ///\n    /// The caller must ensure:\n    /// - `voltage` is non-negative and \u003c= 65.535\n    /// - `soc` is in range 0.0-100.0\n    /// - Both values are finite (not NaN or Infinity)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use battery_estimator::CurvePoint;\n    ///\n    /// // Only use when you're certain the values are valid\n    /// let point = CurvePoint::new_unchecked(3.7, 50.0);\n    /// ```\n    #[inline]\n    pub const fn new_unchecked(voltage: f32, soc: f32) -\u003e Self {\n        Self {\n            voltage_mv: (voltage * 1000.0) as u16,\n            soc_tenth: (soc * 10.0) as u16,\n        }\n    }\n\n    /// Returns the voltage in volts\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use battery_estimator::CurvePoint;\n    ///\n    /// let point = CurvePoint::new(3.7, 50.0);\n    /// assert_eq!(point.voltage(), 3.7);\n    /// ```\n    #[inline]\n    pub const fn voltage(\u0026self) -\u003e f32 {\n        self.voltage_mv as f32 / 1000.0\n    }\n\n    /// Returns the state of charge in percent\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use battery_estimator::CurvePoint;\n    ///\n    /// let point = CurvePoint::new(3.7, 50.0);\n    /// assert_eq!(point.soc(), 50.0);\n    /// ```\n    #[inline]\n    pub const fn soc(\u0026self) -\u003e f32 {\n        self.soc_tenth as f32 / 10.0\n    }\n}\n\nimpl From\u003c(f32, f32)\u003e for CurvePoint {\n    /// Creates a curve point from a tuple (voltage, soc)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use battery_estimator::CurvePoint;\n    ///\n    /// let point: CurvePoint = (3.7, 50.0).into();\n    /// assert_eq!(point.voltage(), 3.7);\n    /// assert_eq!(point.soc(), 50.0);\n    /// ```\n    fn from((voltage, soc): (f32, f32)) -\u003e Self {\n        Self::new(voltage, soc)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_curve_point_creation() {\n        let point = CurvePoint::new(3.7, 50.0);\n        assert_eq!(point.voltage(), 3.7);\n        assert_eq!(point.soc(), 50.0);\n    }\n\n    #[test]\n    fn test_curve_point_zero_values() {\n        let point = CurvePoint::new(0.0, 0.0);\n        assert_eq!(point.voltage(), 0.0);\n        assert_eq!(point.soc(), 0.0);\n    }\n\n    #[test]\n    fn test_curve_point_boundary_values() {\n        // Test maximum voltage (u16 max / 1000 = 65.535V)\n        let max_point = CurvePoint::new(65.535, 100.0);\n        assert_eq!(max_point.voltage(), 65.535);\n        assert_eq!(max_point.soc(), 100.0);\n    }\n\n    #[test]\n    fn test_curve_point_decimal_voltage() {\n        // Test two decimal places\n        let point = CurvePoint::new(3.71, 75.5);\n        assert_eq!(point.voltage(), 3.71);\n        assert_eq!(point.soc(), 75.5);\n    }\n\n    #[test]\n    fn test_curve_point_negative_voltage() {\n        // Test that negative voltage is handled\n        // Note: Negative voltages get stored as u16, so they wrap around\n        // This is expected behavior for the current implementation\n        let point = CurvePoint::new(-1.5, 0.0);\n        // The voltage will be wrapped due to u16 storage\n        assert!(point.voltage() \u003e= 0.0); // Will be positive due to wrapping\n    }\n\n    #[test]\n    fn test_curve_point_soc_bounds() {\n        // Test minimum SOC\n        let min_soc = CurvePoint::new(3.7, 0.0);\n        assert_eq!(min_soc.soc(), 0.0);\n\n        // Test maximum SOC\n        let max_soc = CurvePoint::new(4.2, 100.0);\n        assert_eq!(max_soc.soc(), 100.0);\n    }\n\n    #[test]\n    fn test_curve_point_soc_precision() {\n        // Test that SOC is stored with 0.1% precision\n        let point = CurvePoint::new(3.7, 50.15);\n        // Should be rounded to 50.1 or 50.2 depending on rounding\n        let soc = point.soc();\n        assert!((50.0..=50.2).contains(\u0026soc));\n    }\n\n    #[test]\n    fn test_curve_point_from_tuple() {\n        let point: CurvePoint = (3.8, 75.0).into();\n        assert_eq!(point.voltage(), 3.8);\n        assert_eq!(point.soc(), 75.0);\n    }\n\n    #[test]\n    fn test_curve_point_equality() {\n        let point1 = CurvePoint::new(3.7, 50.0);\n        let point2 = CurvePoint::new(3.7, 50.0);\n        let point3 = CurvePoint::new(3.8, 50.0);\n\n        assert_eq!(point1, point2);\n        assert_ne!(point1, point3);\n    }\n\n    #[test]\n    fn test_curve_point_copy() {\n        let point1 = CurvePoint::new(3.7, 50.0);\n        let point2 = point1;\n        assert_eq!(point1, point2);\n    }\n\n    #[test]\n    fn test_curve_point_voltage_exceeds_max() {\n        // Test voltage \u003e 65.535 is clamped to 65.535\n        let point = CurvePoint::new(100.0, 50.0);\n        assert_eq!(point.voltage(), 65.535);\n    }\n\n    #[test]\n    fn test_curve_point_soc_exceeds_max() {\n        // Test SOC \u003e 100.0 is clamped to 100.0\n        let point = CurvePoint::new(3.7, 150.0);\n        assert_eq!(point.soc(), 100.0);\n    }\n\n    #[test]\n    fn test_curve_point_nan_values() {\n        // Test NaN voltage is treated as 0.0\n        let point = CurvePoint::new(f32::NAN, 50.0);\n        assert_eq!(point.voltage(), 0.0);\n\n        // Test NaN SOC is treated as 0.0\n        let point2 = CurvePoint::new(3.7, f32::NAN);\n        assert_eq!(point2.soc(), 0.0);\n    }\n\n    #[test]\n    fn test_curve_point_infinity_values() {\n        // Test infinity voltage is treated as 0.0\n        let point = CurvePoint::new(f32::INFINITY, 50.0);\n        assert_eq!(point.voltage(), 0.0);\n\n        // Test infinity SOC is treated as 0.0\n        let point2 = CurvePoint::new(3.7, f32::INFINITY);\n        assert_eq!(point2.soc(), 0.0);\n    }\n\n    #[test]\n    fn test_curve_point_from_trait() {\n        // Explicitly test the From trait implementation\n        let tuple = (3.9, 80.0);\n        let point = CurvePoint::from(tuple);\n        assert_eq!(point.voltage(), 3.9);\n        assert_eq!(point.soc(), 80.0);\n    }\n\n    #[test]\n    fn test_curve_point_new_unchecked() {\n        // Test the new_unchecked function\n        let point = CurvePoint::new_unchecked(3.8, 60.0);\n        assert_eq!(point.voltage(), 3.8);\n        assert_eq!(point.soc(), 60.0);\n\n        // Test with edge values\n        let point2 = CurvePoint::new_unchecked(0.0, 0.0);\n        assert_eq!(point2.voltage(), 0.0);\n        assert_eq!(point2.soc(), 0.0);\n\n        let point3 = CurvePoint::new_unchecked(65.535, 100.0);\n        assert_eq!(point3.voltage(), 65.535);\n        assert_eq!(point3.soc(), 100.0);\n    }\n\n    #[test]\n    fn test_curve_point_internal_representation() {\n        let point = CurvePoint::new(3.7, 50.0);\n        // Voltage should be stored in millivolts\n        assert_eq!(point.voltage_mv, 3700);\n        // SOC should be stored in tenths of a percent\n        assert_eq!(point.soc_tenth, 500);\n    }\n\n    #[test]\n    fn test_battery_chemistry_variants() {\n        // Test that all battery chemistry variants can be created\n        let lipo = BatteryChemistry::LiPo;\n        let lifepo4 = BatteryChemistry::LiFePO4;\n        let _lilon = BatteryChemistry::LiIon;\n        let _conservative = BatteryChemistry::Lipo410Full340Cutoff;\n\n        // Test equality\n        assert_eq!(lipo, BatteryChemistry::LiPo);\n        assert_ne!(lipo, lifepo4);\n    }\n\n    #[test]\n    fn test_battery_chemistry_copy() {\n        let chem1 = BatteryChemistry::LiPo;\n        let chem2 = chem1;\n        assert_eq!(chem1, chem2);\n    }\n\n    #[test]\n    fn test_curve_point_extreme_soc() {\n        // Test SOC values beyond normal range\n        // With input validation, negative SOC is clamped to 0\n        let point1 = CurvePoint::new(3.7, -10.0);\n        assert_eq!(point1.soc(), 0.0, \"Negative SOC should be clamped to 0\");\n\n        // SOC above 100% is clamped to 100%\n        let point2 = CurvePoint::new(3.7, 150.0);\n        assert_eq!(\n            point2.soc(),\n            100.0,\n            \"SOC above 100% should be clamped to 100%\"\n        );\n    }\n\n    #[test]\n    fn test_curve_point_voltage_precision() {\n        // Test that voltage precision is maintained\n        let point = CurvePoint::new(3.715, 50.0);\n        // Should be stored and retrieved accurately\n        assert!((point.voltage() - 3.715).abs() \u003c 0.001);\n    }\n}\n","traces":[{"line":12,"address":[505168],"length":1,"stats":{"Line":2},"fn_name":"is_finite_const"},{"line":17,"address":[505178],"length":1,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[505187],"length":1,"stats":{"Line":5},"fn_name":null},{"line":19,"address":[505199],"length":1,"stats":{"Line":11},"fn_name":null},{"line":167,"address":[504800],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[504843,504875],"length":1,"stats":{"Line":3},"fn_name":null},{"line":170,"address":[504866],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[504908,504883],"length":1,"stats":{"Line":22},"fn_name":null},{"line":172,"address":[504910],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[504902],"length":1,"stats":{"Line":11},"fn_name":null},{"line":178,"address":[504962,504930],"length":1,"stats":{"Line":12},"fn_name":null},{"line":179,"address":[504953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[504995,504970],"length":1,"stats":{"Line":22},"fn_name":null},{"line":181,"address":[504997],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[504989],"length":1,"stats":{"Line":11},"fn_name":null},{"line":187,"address":[505011],"length":1,"stats":{"Line":11},"fn_name":null},{"line":188,"address":[505058],"length":1,"stats":{"Line":11},"fn_name":null},{"line":210,"address":[504704],"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[504727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[504768],"length":1,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[505136],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[505141],"length":1,"stats":{"Line":1},"fn_name":null},{"line":243,"address":[505104],"length":1,"stats":{"Line":3},"fn_name":null},{"line":244,"address":[505109],"length":1,"stats":{"Line":3},"fn_name":null},{"line":260,"address":[504672,504656],"length":1,"stats":{"Line":4},"fn_name":"from"},{"line":261,"address":[504684],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":26,"coverable":26}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>